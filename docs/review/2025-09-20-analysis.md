# Project Review and Next Steps — 2025-09-20

This entry builds on the 2025-09-13 review and focuses on clarifying current behavior, surfacing remaining integration gaps for Phase 1, and outlining concrete, incremental next steps.

Date: 2025-09-20

## 1) Current State (Phase 1)

- API (Go + Echo)
  - Auth: Auth0 JWT in production server; test server bypasses JWT and injects `X-Test-User`.
  - Projects: CRUD implemented with user scoping.
  - Uploads: Presigned S3 PUT URLs working with user-aware key scoping.
  - Images:
    - Domain model and handlers in place, including request validation.
    - Endpoints: create image, get by ID, list by project, delete by ID.
    - Status lifecycle defined (`queued`, `processing`, `ready`, `error`).
  - SSE:
    - Endpoint exists and returns a stream when a pub/sub backend is configured.
    - Redis pub/sub adapter is present behind environment-based construction but not guaranteed configured during local runs.
  - Billing:
    - Stripe webhook handler added with signature verification and idempotency backing (processed events).
    - Subscriptions and invoices persisted; listing endpoints implemented and documented.
  - OpenAPI:
    - Spec embedded and served at `/api/v1/docs` with `oas3.yaml` validated by `make docs`.

- Worker
  - Main loop, telemetry, and an events publisher interface are wired.
  - Processor simulates Phase 1 “staging” by generating a `-staged.jpg` URL and logging style/room/seed metadata.
  - Queue client is a mock; no production queue integration is active by default.
  - Best-effort events publication on job state changes if a publisher is configured from env.

- Infra and Schema
  - PostgreSQL schema includes `images` with enum status and indexes.
  - Stripe-related tables and idempotency table added per prior review.
  - Makefile targets for tests, integration testing (dockerized), migrations, linting, and docs validation are available.

- Tests
  - Unit and integration tests exist for API and worker modules.
  - Stripe webhook tests are present; additional coverage around mapping/idempotency recommended (see Next Steps).

## 2) Additional Findings Since 2025-09-13

- Image lifecycle wiring is partially stubbed:
  - The worker’s queue client is mocked; end-to-end delivery from API enqueue -> Redis -> worker -> DB update is not yet fully realized by default.
  - The worker logs a staged URL but does not finalize the image in the DB (status + `staged_url`) in the current Phase 1 processor scaffold.
- SSE broadcasting path is split across services and environment-dependent:
  - The API exposes SSE and the worker can publish events; however, consistent pub/sub configuration (Redis URL, channels, and auth) is required to see real-time updates in local/dev.
- OpenAPI vs. implementation alignment:
  - The spec documents images and billing endpoints; implementations look aligned for the documented routes. Keep the spec authoritative and run `make docs` in CI (already added) to catch future drift.

## 3) Gaps to Close for a Complete Phase 1 E2E

- Job Queue (P0) — Completed on 2025-09-25 (see 2025-09-25-analysis.md)
  - DONE: Replace mock queue client with production-ready Redis/asynq client in worker and API.
  - DONE: Ensure API enqueues `stage:run` with the correct payload on image creation.
  - DONE: Persist job metadata for observability (Phase 1).

- Image Status Updates (P0)
  - Worker must update image row:
    - `processing` when work starts,
    - `ready` + `staged_url` on success,
    - `error` + `error` message on failure.
  - Ensure idempotency in worker updates (safe to retry).

- SSE Broadcasting (P0)
  - Define channels and payload schema (e.g., `jobs:updates` or per-image topics).
  - API SSE handler subscribes; worker publishes on each state transition.
  - Confirm connection lifecycle and heartbeats are robust (avoid idle timeouts).

- Stripe (P0)
  - Finalize unit tests for field mapping (subscriptions/invoices) and idempotency short-circuit.
  - Enforce `STRIPE_WEBHOOK_SECRET` in production (fail fast if missing) and document rotation.

- Integration Tests (P1)
  - Add env-gated test that uploads to MinIO via presigned URL and validates object existence.
  - Add end-to-end “happy path”:
    - Create project -> presign -> upload -> create image -> job runs -> image becomes `ready`.

- Codebase Hygiene (P1)
  - Clarify or remove generic repository methods that are not user-scoped.
  - Ensure consistent error typing for “not found” vs. other DB errors in handlers.

- Docs and DevEx (P1)
  - Publish the API docs (GitHub Pages or similar).
  - Add troubleshooting notes for SSE/Redis and worker queue setup in local dev.

## 4) Proposed Short-Term Milestones (1–2 Weeks)

- Milestone A — Queue + Worker Integration (P0)
  - Introduce real Redis/asynq client:
    - API: enqueue `stage:run` on `POST /images`.
    - Worker: consume tasks; update image status.
  - Acceptance:
    - Creating an image triggers a job; image transitions to `ready` with a staged URL suffix.

- Milestone B — SSE Real-Time Updates (P0)
  - Configure Redis pub/sub:
    - Worker publishes `processing`/`ready`/`failed` events with `image_id` and optional `error`.
    - API SSE subscribes and streams to connected clients.
  - Acceptance:
    - A client connected to `/api/v1/events` receives status changes for images it created.

- Milestone C — Stripe Test Hardening (P0)
  - Add unit tests for signature verification edge cases, mapping, and idempotency.
  - Enforce webhook secret in production mode.
  - Acceptance:
    - All tests pass; webhook rejects invalid signatures; duplicate events are no-ops.

- Milestone D — E2E Integration Test (P1)
  - Add a dockerized integration test:
    - Presign -> upload (MinIO) -> create image -> wait for ready -> verify `staged_url`.
  - Acceptance:
    - Single command executes the full flow reliably in CI (tagged / env-gated as needed).

## 5) Implementation Notes and Interfaces

- Queue
  - Task type: `stage:run`.
  - Payload: `image_id`, `original_url`, optional `room_type`, `style`, `seed`.
  - Consider a thin `JobRepository` only if UI needs visibility; otherwise rely on image status and SSE.

- Worker <-> DB
  - Add an API or repository client inside the worker to update images:
    - Option A: Worker talks directly to the DB (shared sqlc package).
    - Option B: Worker calls API’s internal endpoints (adds auth complexity).
  - Phase 1 recommendation: direct DB access in the worker using a small, explicit repository for images (status updates only).

- SSE
  - Event schema (JSON): `{ "type": "image.update", "image_id": "<uuid>", "status": "processing|ready|error", "error": "<string|null>" }`.
  - Channel: a single `jobs:updates` is sufficient for Phase 1; user scoping can be layered later.

## 6) Risks and Mitigations

- Inconsistent local environments for Redis/MinIO/SSE:
  - Mitigation: Provide a single `make up` profile that brings Redis + MinIO + worker + API with sane defaults; emphasize `.env` examples.
- Double-processing in worker:
  - Mitigation: Make status transitions idempotent and side-effect safe; only set `staged_url` once; log and continue if already `ready`.
- Webhook security lapses:
  - Mitigation: Fail closed when secret is missing in non-dev; add alarm/metric on signature failures.

## 7) Quick Wins

- Add explicit logs for image status transitions (API and worker) with `image_id`.
- Add a “fake processor delay” env var to speed up dev runs.
- Add a “/health” for worker (optional) to report queue connectivity.

## 8) Task Checklist (Rolling)

P0
- [x] Replace mock queue with Redis/asynq in API and worker; define task payload contract. (done 2025-09-25; see 2025-09-25-analysis.md)
- [ ] Worker updates images table on start/success/failure; make updates idempotent.
- [ ] Wire Redis pub/sub for SSE and stream updates in API.
- [ ] Stripe: finalize tests (mapping, idempotency, signature edge cases) and enforce secret in prod.

P1
- [ ] E2E integration test for upload -> job -> ready (env-gated).
- [ ] Decide fate of generic repository methods (filter by user vs. remove).
- [ ] Publish API docs via Pages and add CI check.

P2
- [ ] Observability polish: spans around enqueue/process/update/publish; structured logs.
- [ ] Frontend bootstrap (Next.js) consuming projects, uploads, images, billing, and SSE.

## 9) How to Verify Locally (Once P0 Lands)

- Start stack:
  - `make up` (API, worker, Postgres, Redis, MinIO)
- Create a project and upload:
  - Create project via API.
  - Get presigned URL; PUT an image to MinIO.
  - Create image with `original_url`.
- Watch SSE:
  - Connect to `/api/v1/events` and observe `processing` -> `ready`.
- Confirm DB:
  - `images.staged_url` is set and `status = ready`.

---

Ownership Notes
- These steps are non-breaking to the current public API.
- Frontend work can start in parallel; initially mock SSE and flip to live once Redis pub/sub is configured.
