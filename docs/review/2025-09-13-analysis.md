# Project Review and Next Steps — Virtual Staging AI

New Billing Endpoints (added 2025-09-13)
- GET /api/v1/billing/subscriptions
  - Returns the current user's subscriptions.
  - Fields: id, stripe_subscription_id, status, price_id, current_period_start, current_period_end, cancel_at, canceled_at, cancel_at_period_end, created_at, updated_at.
- GET /api/v1/billing/invoices
  - Returns the current user's invoices.
  - Fields: id, stripe_invoice_id, stripe_subscription_id, status, amount_due, amount_paid, currency, invoice_number, created_at, updated_at.

Pagination
- limit: integer, default 50, max 100
- offset: integer, default 0

Auth and Environment
- Production server: JWT required (Authorization: Bearer <token>).
- Test server: routes are public; X-Test-User is auto-set. You can override identity with header X-Test-User: <auth0_sub>.

Quick usage
- Subscriptions:
  curl -H "Authorization: Bearer <token>" http://localhost:8080/api/v1/billing/subscriptions
- Invoices:
  curl -H "Authorization: Bearer <token>" http://localhost:8080/api/v1/billing/invoices
- With pagination:
  curl -H "Authorization: Bearer <token>" "http://localhost:8080/api/v1/billing/invoices?limit=20&offset=0"

Update: 2025-09-13 Stripe Implementation Progress
- Implemented webhook signature verification in the Stripe webhook handler (HMAC-SHA256 over "t.body" with configurable timestamp tolerance and constant-time comparison).
- Implemented idempotency backed by the processed_events table and repository; webhook handler short-circuits duplicate events using the DB record.
- Added database migrations for Stripe-related tables:
  - processed_events (webhook idempotency)
  - subscriptions (per-user subscription state)
  - invoices (invoice-level persistence and analytics)
- Added sqlc queries for:
  - Processed events (get, create, upsert, retention)
  - Subscriptions (upsert by stripe_subscription_id, get, list by user, delete)
  - Invoices (upsert by stripe_invoice_id, get by stripe ID, list by user)
- Added repositories for processed events, subscriptions, and invoices; wired idempotency to use the processed events repository from the webhook handler.
- Wired subscription persistence in handlers (created/updated/deleted), implemented subscription field mapping (price_id, current_period_start/end, cancel flags), and linked stripe_customer_id to the user on checkout.session.completed when client_reference_id is present.
- Wired invoices persistence in webhook handlers:
  - invoice.payment_succeeded and invoice.payment_failed now upsert invoices (amounts, status, currency, subscription link) for the resolved user via stripe_customer_id.
- Next steps to complete Stripe:
  - Unit tests covering subscription field mapping and invoices persistence.
  - Unit tests for signature verification, timestamp tolerance, and handler flows; add env-gated integration tests.
  - Enforce STRIPE_WEBHOOK_SECRET in production environments and document rotation.

Date: 2025-09-13

Scope
This document captures a deep-dive review of the repository, outstanding TODOs, concrete fixes applied during the review, and a prioritized plan to complete Stripe integration and other next steps.

1) Summary: Current State
- API (Go + Echo)
  - Project CRUD: Implemented with user-scoped repository methods and auth-backed user resolution.
  - File uploads: Presigned S3 PUT URLs implemented with validation. Updated to use authenticated user (or test default) and ensure `users` row exists.
  - Images: Endpoints for creation/status exist (Phase 1 “placeholder” staging behavior as per docs).
  - SSE: Endpoint provides connection + heartbeats. Broadcasting not yet wired to a broker.
  - Auth: JWT middleware for production server; test server intentionally runs without auth to ease integration tests.
  - Stripe: Webhook endpoint implemented with signature verification, idempotency (processed events), and persistence for subscriptions and invoices.

- Storage and Repositories
  - Users: Support Auth0 subject, optional Stripe customer ID, roles; repository methods exist.
  - Projects: Both general methods and user-scoped methods exist; handlers use user-scoped methods.
  - sqlc-based storage: Present for projects; patterns exist to extend to new tables.

- Tests
  - Integration tests cover projects and uploads (request validation, error cases).
  - Stripe webhook tests validate routing and basic behavior but do not verify signature or persistence.

- Docs
  - Strong coverage across architecture, API service, worker, DB schema, local development, configuration, deployment, and roadmap.
  - API docs are served from `/api/v1/docs` with OpenAPI spec checked in.
  - Remaining docs item: publish API docs via GitHub Pages.

- Worker
  - Present with queue/telemetry scaffolding; no open TODOs detected.

2) Changes Applied During This Review
- Upload presign handler: Removed the hardcoded user ID. Now:
  - Extracts the Auth0 subject from JWT (or uses default in test mode),
  - Ensures a `users` row exists (create if not found),
  - Uses that user ID for S3 key scoping.
- Test suite comments: Replaced outdated “Add Authorization header” TODOs with a note clarifying the test server disables auth.
- Stripe webhook: When `STRIPE_WEBHOOK_SECRET` is not configured, we now explicitly log and continue (acceptable for dev; MUST be configured in prod).
- SSE: Clarified the TODO to a concrete plan: integrate Redis Pub/Sub for broadcasting job updates from worker to SSE subscribers.

3) Outstanding TODOs (Inventory and Status)
- Stripe Webhook (open):
  - Signature verification using Stripe-Signature and endpoint secret.
  - Persistence logic for:
    - Associating Stripe customer to user,
    - Subscriptions lifecycle (created/updated/deleted),
    - Invoices and payment status,
    - Idempotency (prevent duplicate event processing).
- SSE (open):
  - Implement Redis Pub/Sub for broadcasting job updates.
- Project repository generic methods (open/clarify):
  - TODOs to “Filter by user” on generic methods remain. The handlers already use user-scoped methods.
  - Decision: either add filtering to generic methods, mark them as admin/internal-only, or remove them if unused.
- Upload presign integration test for actual PUT (open but documented):
  - Kept disabled by default (env-gated) with guidance on how to enable and verify against real S3/MinIO.
- Docs:
  - Publish API docs to GitHub Pages.
  - Select a license (LICENSE.md still indicates TBD).

4) Are We Complete with the Backend API?
- Nearly there for Phase 1, but not production-complete.
- Gaps to close:
  - Stripe signature verification + subscription/invoice persistence + idempotency.
  - SSE broadcasting via broker.
  - Optional: finalize repository cleanup (generic vs. user-scoped methods).

5) Can/Should We Start Frontend Work?
- Yes. Recommend starting the Next.js application (Milestone 4) and wiring Auth0 + basic dashboard + upload flow UI in parallel.
- Stripe and SSE can be mocked on frontend initially; then switch to live once backend pieces land.

6) Prioritized Next Steps
P0 — Stripe Productionization
- Signature verification for webhooks.
- Persistence model for customer/subscription/invoice data.
- Idempotent processing (event log).
- Tests (unit + integration) and config hardening.

P0 — SSE Broadcasting
- Redis Pub/Sub integration.
- Wire worker to publish job updates; SSE handler subscribes and streams.
- Connection lifecycle and back-pressure handling.

P1 — Repository/Codebase Cleanup
- Decide fate of generic project methods. Either implement user filtering (if needed) or mark/remove for clarity.

P1 — CI/CD & Docs
- Publish API docs via GitHub Pages.
- Select a license.
- Add CI for lint/test; add preview environment pipeline if possible.

P2 — Integration Tests
- Add env-gated S3 PUT test for presigned URLs (optional but valuable).
- E2E “happy path” test as per Milestone 5.

7) Stripe Implementation Plan (Detailed)
7.1 Webhook Signature Verification
- Goal: Verify Stripe signature per official scheme.
- Inputs:
  - Header: “Stripe-Signature” (format: t=timestamp,v1=signature[,v1=…]).
  - Secret: STRIPE_WEBHOOK_SECRET.
  - Payload: raw request body (exact bytes).
- Steps:
  1) Extract `t` (timestamp) and `v1` (the HMAC-SHA256 signature).
  2) Construct signed payload: `<timestamp>.<raw_body>`.
  3) Compute HMAC-SHA256 of signed payload using `STRIPE_WEBHOOK_SECRET`.
  4) Compare computed signature with `v1` (timing-safe compare).
  5) Enforce a timestamp tolerance window (e.g., ±300s) to mitigate replay.
- Return 401 Unauthorized on failure.

Example helper outline:
```
func verifyStripeSignature(body []byte, sigHeader, secret string, tolerance time.Duration, now func() time.Time) error {
    // Parse sigHeader -> extract timestamp t and all v1 signatures
    // If missing parts -> error
    // Compute expectedSig := HMAC_SHA256(secret, fmt.Sprintf("%s.%s", t, body))
    // Check any provided v1 == expectedSig (constant-time compare)
    // Check |now()-t| <= tolerance
    // Return nil on success; otherwise error
}
```

7.2 Event Idempotency
- Create a table to log processed events (unique by Stripe event ID):
  - processed_events
    - id UUID (pk), stripe_event_id text unique not null, received_at timestamptz not null, payload jsonb (optional), type text (optional).
- At the start of webhook handling (after verification), insert the event ID; if conflict occurs (already processed), skip and return 200.

7.3 Persistence Model (Phase 1)
- Reuse existing users table and user repository; ensure we can:
  - Update a user’s `stripe_customer_id` when first seen.
  - Resolve user by `stripe_customer_id` (already implemented).
- Add subscriptions table:
  - subscriptions
    - id UUID (pk)
    - user_id UUID not null references users(id)
    - stripe_subscription_id text unique not null
    - status text not null (active, trialing, past_due, canceled, incomplete, incomplete_expired, unpaid, paused, etc.)
    - plan_id text (or price_id) — if tracking plan/price
    - current_period_end timestamptz
    - created_at timestamptz not null default now()
    - updated_at timestamptz not null default now()
- Add invoices/payments table (optional for Phase 1; recommended for analytics/auditing):
  - invoices
    - id UUID (pk)
    - user_id UUID not null
    - stripe_invoice_id text unique not null
    - stripe_subscription_id text (nullable)
    - amount_paid integer not null default 0 (cents)
    - status text not null (paid, open, uncollectible, void, etc.)
    - created_at timestamptz not null default now()

7.4 Handler Logic Mapping
- checkout.session.completed:
  - Extract customer ID, client_reference_id (often your internal user ID if you set it in Checkout).
  - Map to user: If `client_reference_id` exists and corresponds to our user, update user.stripe_customer_id if missing.
  - Optionally kick off provisioning (activate plan).
- customer.subscription.created:
  - Find user by `customer` via `GetByStripeCustomerID`.
  - Upsert into subscriptions with initial status, plan/price, and period end.
- customer.subscription.updated:
  - Update subscription status / period end / plan/price; if status transitions to active/past_due, reflect in user entitlements.
- customer.subscription.deleted:
  - Mark subscription as canceled/deactivated (soft-delete or status update).
- invoice.payment_succeeded:
  - Upsert invoice record with paid status and amount.
  - Optional: mark user as active if plan gating requires a paid invoice.
- invoice.payment_failed:
  - Upsert invoice with failed status.
  - Optional: trigger notifications / degrade access after grace period.
- customer.created/updated/deleted:
  - Keep minimal customer info if needed; link by `stripe_customer_id`.
  - For deletion, consider data retention policy; do not delete users, but clear Stripe link if appropriate.

7.5 Repository Additions (sketch)
- Users:
  - Already: GetByStripeCustomerID, UpdateStripeCustomerID
- Subscriptions (new):
  - UpsertByStripeID(userID, stripeSubID, status, planID, periodEnd)
  - GetByStripeID(stripeSubID)
- Invoices (optional new):
  - UpsertByStripeID(userID, stripeInvoiceID, stripeSubID, amountPaid, status)
- ProcessedEvents (new):
  - InsertIfNotExists(eventID) -> (inserted bool, err)

7.6 Migrations and sqlc
- Add SQL migrations creating tables with indexes and unique constraints.
- Add queries in `apps/api/internal/storage/queries/*.sql`.
- Run sqlc to generate types; wire into repositories.

7.7 Configuration and Security
- Require `STRIPE_WEBHOOK_SECRET` in production.
- Consider a separate secret for each environment; document rotation steps.
- Ensure logging redacts PII; store only what’s needed for operations.

7.8 Testing
- Unit tests:
  - Signature parsing and verification (valid, invalid secret, replay/timestamp out-of-window).
  - Idempotency (same event twice should process once).
  - Each event handler with valid payload shapes and error paths.
- Integration tests (env-gated):
  - Use Stripe CLI to forward to local webhook endpoint (document steps).
  - Validate DB is updated accordingly.

8) SSE Implementation Plan
- Broker: Redis Pub/Sub.
- Flow:
  - Worker publishes job updates to `jobs:{job_id}` channel with JSON payload {job_id, image_id, status, error, progress}.
  - SSE handler:
    - On new client connection: subscribe to a general channel (e.g., `jobs:updates`) or per-user channels (if scoping is required later).
    - Stream received messages as SSE events.
    - Keep heartbeat tick to avoid idle disconnects.
  - Server: Maintain subscription cleanup on client disconnect (context cancellation).
- Testing:
  - Unit test the SSE handler with a mock subscriber.
  - Integration test with Redis in docker-compose (env-gated) to publish and receive.

9) Frontend Guidance (Parallel Start)
- Create Next.js app under `/apps/web`.
- Wire Auth0 (same domain/audience), fetch JWT, call protected APIs.
- Implement:
  - Projects dashboard (list/create/update/delete),
  - Upload flow using presigned URLs,
  - Images listing/status, Billing pages (subscriptions/invoices) using new endpoints,
  - Webhook status display (eventually),
  - Stripe checkout button/flow (later).
- Mock SSE initially; switch to live once Redis Pub/Sub lands.

10) Risks and Mitigations
- Webhook security:
  - Must enforce signature verification and timestamp tolerance in prod.
- Idempotency:
  - Use processed events table to prevent duplicate side effects.
- Data modeling:
  - Keep Stripe entities normalized; avoid denormalized copies of payloads unless needed.
- Operational visibility:
  - Add tracing and structured logs around webhook paths, SSE publish/subscribe, and queue operations.

Appendix: Quick Task Checklist
- Stripe
  - [x] Add verifyStripeSignature helper with tolerance and constant-time compare
  - [x] Add processed_events table and repository
  - [x] Add subscriptions (and optional invoices) tables + repositories
  - [x] Implement webhook handlers to persist user/subscription/invoice data
  - [ ] Unit tests for handlers; env-gated integration tests (signature and repository unit tests added)
  - [ ] Require STRIPE_WEBHOOK_SECRET in prod (currently logs and skips when unset)
- SSE
  - [ ] Integrate Redis Pub/Sub for job updates
  - [ ] Subscribe in SSE handler; publish from worker
  - [ ] Tests for stream behavior and disconnect cleanup
- Cleanup/Infra/Docs
  - [ ] Clarify/remove generic project repo TODOs
  - [ ] Publish API docs (GitHub Pages)
  - [ ] Choose license
  - [x] CI: lint/test; add preview environment (CI added; preview pipeline TBD)

Ownership Notes
- This plan is non-breaking to current APIs.
- Frontend work can proceed in parallel with mocks, switching to live endpoints incrementally.

## New Unit Tests Added — 2025-09-13
- Stripe signature verification:
  - parseStripeSignatureHeader: valid headers, missing/invalid timestamp, invalid v1 hex.
  - verifyStripeSignature: valid signature, multiple signatures (one matching), missing header, missing v1, mismatched signature, timestamp outside tolerance.
- Repositories:
  - InvoicesRepository: Upsert and GetByStripeID success paths; not-found behavior.
  - ProcessedEventsRepository: IsProcessed true/false cases, Upsert/Get round-trip, DeleteOlderThan execution.
  - SubscriptionsRepository: UpsertByStripeID (full field set), GetByStripeID success, validation error for invalid user ID, DeleteByStripeID execution.

### How to run these tests
- Run specific HTTP signature tests:
  - cd apps/api && go test ./internal/http -run StripeSignature
- Run stripe package repository tests:
  - cd apps/api && go test ./internal/stripe -v
- Run only repository tests by name:
  - cd apps/api && go test ./internal/stripe -run 'InvoicesRepository|ProcessedEventsRepository|SubscriptionsRepository'
- Full API test suite (note: some unrelated tests may be failing if services aren’t configured):
  - cd apps/api && go test ./...

## Update: Docs Serving — 2025-09-13
- API docs are now embedded into the API binary via `go:embed` and served at `/api/v1/docs`.
- Source moved to `apps/api/web/api/v1` and routed through `web.RegisterRoutes(e)`.
- Docker Compose no longer mounts docs; rebuild picks up changes.
- Makefile `docs` target updated to validate `apps/api/web/api/v1/oas3.yaml`.

Quick verification
- make down && make up
- curl -I http://localhost:8080/api/v1/docs/
- curl -I http://localhost:8080/api/v1/docs/oas3.yaml

Optional dev toggle (future)
- Add `DOCS_FS=1` to prefer filesystem over embedded for live editing.
- Implementation: if env set and path exists, serve `apps/api/web/api/v1` via `e.Static` before falling back to embedded.

## Next Incremental Tasks
- Stripe tests: finalize unit tests around field mapping and idempotency paths.
- SSE: implement Redis Pub/Sub wiring and minimal integration test.
- Docs: publish to GitHub Pages; add CI check to run `make docs`.
- Makefile: add `make openapi-bundle` if we introduce multi-file specs later.

Update 2025-09-13 — CI for Docs and Tests
- Added GitHub Actions workflow `.github/workflows/ci.yml`:
  - Runs Go builds for `apps/api` and `apps/worker`.
  - Executes unit tests via `make test`.
  - Validates OpenAPI spec via `make docs`.
  - Triggers on push and PR to main/master.
