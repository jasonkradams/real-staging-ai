# Project Review and Next Steps — 2025-09-25

This entry records completion of the Job Queue integration for Phase 1. The API now enqueues production jobs to Redis via asynq and the Worker consumes them via an asynq-backed queue client, replacing the previous mock-only setup.

Date: 2025-09-25

## 1) Summary: What Landed

- Replaced the mock queue with a production-ready Redis/asynq integration:
  - API: enqueues `stage:run` tasks on image creation with the correct payload.
  - Worker: consumes tasks from Redis using an asynq-backed client (auto-fallback to mock if `REDIS_ADDR` is not set).
- Continued persistence of job metadata in Postgres (`jobs` table) for observability.
- Docker Compose already includes Redis and sets `REDIS_ADDR` for both API and Worker, enabling E2E delivery by default in local dev.

Scope note: This change completes the “Job Queue (P0)” and “Image Status Updates (P0)” work items. The worker now marks images processing/ready/error with idempotent updates; “SSE Broadcasting (P0)” will follow as the next increment.

## 2) Implementation Details

- Task type: `stage:run`
- Enqueued by API on `POST /api/v1/images` (after creating the image & job metadata row).
- Payload contract (Phase 1):
  - `image_id` (string, required)
  - `original_url` (string, required)
  - `room_type` (string, optional)
  - `style` (string, optional)
  - `seed` (int64, optional)

Example payload:
```json
{
  "image_id": "e.g., uuid",
  "original_url": "s3://bucket/key.jpg",
  "room_type": "living_room",
  "style": "modern",
  "seed": 12345
}
```

- API enqueuer:
  - Redis + asynq client constructed from env.
  - Validates payload and enqueues to a configurable queue (defaults to `default`).
  - Falls back to a no-op enqueuer only when `REDIS_ADDR` is unset (primarily for tests without Redis).

- Worker queue client:
  - Uses an asynq server to pull tasks from Redis and bridges them into the existing polling loop through an internal channel.
  - Acknowledges success/failure back to asynq when the loop calls “completed/failed”.
  - Auto-fallback to a mock queue client if `REDIS_ADDR` is unset.

- Job metadata:
  - The API still writes to the `jobs` table when an image is created. This supports simple observability and audit without requiring an external asynq dashboard.

- Environment:
  - `REDIS_ADDR` (required for production queue; e.g., `redis:6379`)
  - `JOB_QUEUE_NAME` (optional, default `default`)
  - `WORKER_CONCURRENCY` (optional, default `5`)

## 3) How to Verify Locally

- Start stack:
  - `make up` (brings up API, Worker, Postgres, Redis, MinIO)
- Create a project and upload:
  - Create a project via API.
  - Presign -> PUT an image to MinIO.
  - Create an image with `original_url` pointing to the uploaded object.
- Observe:
  - API logs should show a successful enqueue of `stage:run`.
  - Worker logs should show:
    - “Using Asynq queue backend”
    - “Processing job … type stage:run”
  - The `jobs` table should contain a row for the enqueued job.
- Note: For Phase 1, the worker still simulates the staged output; DB status updates (`processing`/`ready`/`error`) and SSE emissions are coming next.

## 4) Current State vs. 2025-09-20

Addressed:
- “Job Queue (P0)”
  - Replaced mock queue client with production-ready Redis/asynq client in worker and API.
  - Ensured API enqueues `stage:run` with the correct payload on image creation.
  - Kept job metadata persistence for observability.

Still open:
- “Image Status Updates (P0)”
  - Worker should update `images` on state transitions (`processing`, `ready` + `staged_url`, `error` + `error` message) with idempotency.
- “SSE Broadcasting (P0)”
  - Finalize channels and payload schema; ensure worker publishes and API SSE subscribes; verify heartbeats.
- “Stripe (P0)”
  - Test hardening for field mapping + idempotency and prod secret enforcement.

## 5) Risks and Mitigations

- Missing `REDIS_ADDR` in certain environments:
  - Behavior: API uses a no-op enqueuer; Worker uses mock queue; jobs won’t run.
  - Mitigation: Document required env; docker-compose sets this for local dev. Add startup checks/warnings (done via logs).
- Visibility into queue state:
  - Mitigation: We persist job metadata in Postgres and can add spans/logs around enqueue/process/complete. asynqmon can be introduced later if desired.

## 6) Next Steps (Proposed Order)

1) Image Status Updates (P0)
- Worker updates `images` table (idempotent transitions):
  - `processing` when work starts,
  - `ready` + `staged_url` on success,
  - `error` + message on failure.

2) SSE Real-Time Updates (P0)
- Publish on each state change; align API SSE consumer to emit:
  - `{ "type": "image.update", "image_id": "<uuid>", "status": "<status>", "error": "<string|null>" }`

3) Stripe Test Hardening (P0)
- Unit tests for mapping + idempotency; enforce `STRIPE_WEBHOOK_SECRET` in non-dev modes.

4) E2E Integration Test (P1)
- Presign -> upload -> create image -> wait for “ready” -> verify `staged_url`.

## 7) Quick Wins Logged for This Phase

- Log lines on enqueue and worker consumption include `image_id` to aid tracing.
- Exposed queue name and concurrency via env for quick tuning in dev.
- Kept a safe fallback to keep unit/integration tests runnable without Redis.

## 8) Acceptance Snapshot (for this increment)

- Creating an image leads to:
  - A DB job row persisted, and
  - An asynq task enqueued in Redis,
  - Worker receives and processes the task (Phase 1 simulated processing).
- Not yet in this increment: image status DB transitions and SSE emissions (tracked as next P0).
