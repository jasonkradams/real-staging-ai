// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package billing

import (
	"context"
	"github.com/labstack/echo/v4"
	"sync"
)

// Ensure, that HandlerMock does implement Handler.
// If this is not the case, regenerate this file with moq.
var _ Handler = &HandlerMock{}

// HandlerMock is a mock implementation of Handler.
//
//	func TestSomethingThatUsesHandler(t *testing.T) {
//
//		// make and configure a mocked Handler
//		mockedHandler := &HandlerMock{
//			GetMyInvoicesFunc: func(c echo.Context) error {
//				panic("mock out the GetMyInvoices method")
//			},
//			GetMySubscriptionsFunc: func(c echo.Context) error {
//				panic("mock out the GetMySubscriptions method")
//			},
//		}
//
//		// use mockedHandler in code that requires Handler
//		// and then make assertions.
//
//	}
type HandlerMock struct {
	// GetMyInvoicesFunc mocks the GetMyInvoices method.
	GetMyInvoicesFunc func(c echo.Context) error

	// GetMySubscriptionsFunc mocks the GetMySubscriptions method.
	GetMySubscriptionsFunc func(c echo.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// GetMyInvoices holds details about calls to the GetMyInvoices method.
		GetMyInvoices []struct {
			// C is the c argument value.
			C echo.Context
		}
		// GetMySubscriptions holds details about calls to the GetMySubscriptions method.
		GetMySubscriptions []struct {
			// C is the c argument value.
			C echo.Context
		}
	}
	lockGetMyInvoices      sync.RWMutex
	lockGetMySubscriptions sync.RWMutex
}

// GetMyInvoices calls GetMyInvoicesFunc.
func (mock *HandlerMock) GetMyInvoices(c echo.Context) error {
	if mock.GetMyInvoicesFunc == nil {
		panic("HandlerMock.GetMyInvoicesFunc: method is nil but Handler.GetMyInvoices was just called")
	}
	callInfo := struct {
		C echo.Context
	}{
		C: c,
	}
	mock.lockGetMyInvoices.Lock()
	mock.calls.GetMyInvoices = append(mock.calls.GetMyInvoices, callInfo)
	mock.lockGetMyInvoices.Unlock()
	return mock.GetMyInvoicesFunc(c)
}

// GetMyInvoicesCalls gets all the calls that were made to GetMyInvoices.
// Check the length with:
//
//	len(mockedHandler.GetMyInvoicesCalls())
func (mock *HandlerMock) GetMyInvoicesCalls() []struct {
	C echo.Context
} {
	var calls []struct {
		C echo.Context
	}
	mock.lockGetMyInvoices.RLock()
	calls = mock.calls.GetMyInvoices
	mock.lockGetMyInvoices.RUnlock()
	return calls
}

// GetMySubscriptions calls GetMySubscriptionsFunc.
func (mock *HandlerMock) GetMySubscriptions(c echo.Context) error {
	if mock.GetMySubscriptionsFunc == nil {
		panic("HandlerMock.GetMySubscriptionsFunc: method is nil but Handler.GetMySubscriptions was just called")
	}
	callInfo := struct {
		C echo.Context
	}{
		C: c,
	}
	mock.lockGetMySubscriptions.Lock()
	mock.calls.GetMySubscriptions = append(mock.calls.GetMySubscriptions, callInfo)
	mock.lockGetMySubscriptions.Unlock()
	return mock.GetMySubscriptionsFunc(c)
}

// GetMySubscriptionsCalls gets all the calls that were made to GetMySubscriptions.
// Check the length with:
//
//	len(mockedHandler.GetMySubscriptionsCalls())
func (mock *HandlerMock) GetMySubscriptionsCalls() []struct {
	C echo.Context
} {
	var calls []struct {
		C echo.Context
	}
	mock.lockGetMySubscriptions.RLock()
	calls = mock.calls.GetMySubscriptions
	mock.lockGetMySubscriptions.RUnlock()
	return calls
}

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//	func TestSomethingThatUsesService(t *testing.T) {
//
//		// make and configure a mocked Service
//		mockedService := &ServiceMock{
//			ListInvoicesForUserFunc: func(ctx context.Context, userID string, p Pagination) ([]InvoiceDTO, error) {
//				panic("mock out the ListInvoicesForUser method")
//			},
//			ListSubscriptionsForUserFunc: func(ctx context.Context, userID string, p Pagination) ([]SubscriptionDTO, error) {
//				panic("mock out the ListSubscriptionsForUser method")
//			},
//		}
//
//		// use mockedService in code that requires Service
//		// and then make assertions.
//
//	}
type ServiceMock struct {
	// ListInvoicesForUserFunc mocks the ListInvoicesForUser method.
	ListInvoicesForUserFunc func(ctx context.Context, userID string, p Pagination) ([]InvoiceDTO, error)

	// ListSubscriptionsForUserFunc mocks the ListSubscriptionsForUser method.
	ListSubscriptionsForUserFunc func(ctx context.Context, userID string, p Pagination) ([]SubscriptionDTO, error)

	// calls tracks calls to the methods.
	calls struct {
		// ListInvoicesForUser holds details about calls to the ListInvoicesForUser method.
		ListInvoicesForUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
			// P is the p argument value.
			P Pagination
		}
		// ListSubscriptionsForUser holds details about calls to the ListSubscriptionsForUser method.
		ListSubscriptionsForUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
			// P is the p argument value.
			P Pagination
		}
	}
	lockListInvoicesForUser      sync.RWMutex
	lockListSubscriptionsForUser sync.RWMutex
}

// ListInvoicesForUser calls ListInvoicesForUserFunc.
func (mock *ServiceMock) ListInvoicesForUser(ctx context.Context, userID string, p Pagination) ([]InvoiceDTO, error) {
	if mock.ListInvoicesForUserFunc == nil {
		panic("ServiceMock.ListInvoicesForUserFunc: method is nil but Service.ListInvoicesForUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
		P      Pagination
	}{
		Ctx:    ctx,
		UserID: userID,
		P:      p,
	}
	mock.lockListInvoicesForUser.Lock()
	mock.calls.ListInvoicesForUser = append(mock.calls.ListInvoicesForUser, callInfo)
	mock.lockListInvoicesForUser.Unlock()
	return mock.ListInvoicesForUserFunc(ctx, userID, p)
}

// ListInvoicesForUserCalls gets all the calls that were made to ListInvoicesForUser.
// Check the length with:
//
//	len(mockedService.ListInvoicesForUserCalls())
func (mock *ServiceMock) ListInvoicesForUserCalls() []struct {
	Ctx    context.Context
	UserID string
	P      Pagination
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
		P      Pagination
	}
	mock.lockListInvoicesForUser.RLock()
	calls = mock.calls.ListInvoicesForUser
	mock.lockListInvoicesForUser.RUnlock()
	return calls
}

// ListSubscriptionsForUser calls ListSubscriptionsForUserFunc.
func (mock *ServiceMock) ListSubscriptionsForUser(ctx context.Context, userID string, p Pagination) ([]SubscriptionDTO, error) {
	if mock.ListSubscriptionsForUserFunc == nil {
		panic("ServiceMock.ListSubscriptionsForUserFunc: method is nil but Service.ListSubscriptionsForUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
		P      Pagination
	}{
		Ctx:    ctx,
		UserID: userID,
		P:      p,
	}
	mock.lockListSubscriptionsForUser.Lock()
	mock.calls.ListSubscriptionsForUser = append(mock.calls.ListSubscriptionsForUser, callInfo)
	mock.lockListSubscriptionsForUser.Unlock()
	return mock.ListSubscriptionsForUserFunc(ctx, userID, p)
}

// ListSubscriptionsForUserCalls gets all the calls that were made to ListSubscriptionsForUser.
// Check the length with:
//
//	len(mockedService.ListSubscriptionsForUserCalls())
func (mock *ServiceMock) ListSubscriptionsForUserCalls() []struct {
	Ctx    context.Context
	UserID string
	P      Pagination
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
		P      Pagination
	}
	mock.lockListSubscriptionsForUser.RLock()
	calls = mock.calls.ListSubscriptionsForUser
	mock.lockListSubscriptionsForUser.RUnlock()
	return calls
}
