// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package job

import (
	"context"
	"github.com/virtual-staging-ai/api/internal/storage/queries"
	"sync"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			CompleteJobFunc: func(ctx context.Context, jobID string) (*queries.Job, error) {
//				panic("mock out the CompleteJob method")
//			},
//			CreateJobFunc: func(ctx context.Context, imageID string, jobType string, payloadJSON []byte) (*queries.Job, error) {
//				panic("mock out the CreateJob method")
//			},
//			DeleteJobFunc: func(ctx context.Context, jobID string) error {
//				panic("mock out the DeleteJob method")
//			},
//			DeleteJobsByImageIDFunc: func(ctx context.Context, imageID string) error {
//				panic("mock out the DeleteJobsByImageID method")
//			},
//			FailJobFunc: func(ctx context.Context, jobID string, errorMsg string) (*queries.Job, error) {
//				panic("mock out the FailJob method")
//			},
//			GetJobByIDFunc: func(ctx context.Context, jobID string) (*queries.Job, error) {
//				panic("mock out the GetJobByID method")
//			},
//			GetJobsByImageIDFunc: func(ctx context.Context, imageID string) ([]*queries.Job, error) {
//				panic("mock out the GetJobsByImageID method")
//			},
//			GetPendingJobsFunc: func(ctx context.Context, limit int) ([]*queries.Job, error) {
//				panic("mock out the GetPendingJobs method")
//			},
//			StartJobFunc: func(ctx context.Context, jobID string) (*queries.Job, error) {
//				panic("mock out the StartJob method")
//			},
//			UpdateJobStatusFunc: func(ctx context.Context, jobID string, status string) (*queries.Job, error) {
//				panic("mock out the UpdateJobStatus method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// CompleteJobFunc mocks the CompleteJob method.
	CompleteJobFunc func(ctx context.Context, jobID string) (*queries.Job, error)

	// CreateJobFunc mocks the CreateJob method.
	CreateJobFunc func(ctx context.Context, imageID string, jobType string, payloadJSON []byte) (*queries.Job, error)

	// DeleteJobFunc mocks the DeleteJob method.
	DeleteJobFunc func(ctx context.Context, jobID string) error

	// DeleteJobsByImageIDFunc mocks the DeleteJobsByImageID method.
	DeleteJobsByImageIDFunc func(ctx context.Context, imageID string) error

	// FailJobFunc mocks the FailJob method.
	FailJobFunc func(ctx context.Context, jobID string, errorMsg string) (*queries.Job, error)

	// GetJobByIDFunc mocks the GetJobByID method.
	GetJobByIDFunc func(ctx context.Context, jobID string) (*queries.Job, error)

	// GetJobsByImageIDFunc mocks the GetJobsByImageID method.
	GetJobsByImageIDFunc func(ctx context.Context, imageID string) ([]*queries.Job, error)

	// GetPendingJobsFunc mocks the GetPendingJobs method.
	GetPendingJobsFunc func(ctx context.Context, limit int) ([]*queries.Job, error)

	// StartJobFunc mocks the StartJob method.
	StartJobFunc func(ctx context.Context, jobID string) (*queries.Job, error)

	// UpdateJobStatusFunc mocks the UpdateJobStatus method.
	UpdateJobStatusFunc func(ctx context.Context, jobID string, status string) (*queries.Job, error)

	// calls tracks calls to the methods.
	calls struct {
		// CompleteJob holds details about calls to the CompleteJob method.
		CompleteJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
		}
		// CreateJob holds details about calls to the CreateJob method.
		CreateJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID string
			// JobType is the jobType argument value.
			JobType string
			// PayloadJSON is the payloadJSON argument value.
			PayloadJSON []byte
		}
		// DeleteJob holds details about calls to the DeleteJob method.
		DeleteJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
		}
		// DeleteJobsByImageID holds details about calls to the DeleteJobsByImageID method.
		DeleteJobsByImageID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID string
		}
		// FailJob holds details about calls to the FailJob method.
		FailJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
			// ErrorMsg is the errorMsg argument value.
			ErrorMsg string
		}
		// GetJobByID holds details about calls to the GetJobByID method.
		GetJobByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
		}
		// GetJobsByImageID holds details about calls to the GetJobsByImageID method.
		GetJobsByImageID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID string
		}
		// GetPendingJobs holds details about calls to the GetPendingJobs method.
		GetPendingJobs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int
		}
		// StartJob holds details about calls to the StartJob method.
		StartJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
		}
		// UpdateJobStatus holds details about calls to the UpdateJobStatus method.
		UpdateJobStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// JobID is the jobID argument value.
			JobID string
			// Status is the status argument value.
			Status string
		}
	}
	lockCompleteJob         sync.RWMutex
	lockCreateJob           sync.RWMutex
	lockDeleteJob           sync.RWMutex
	lockDeleteJobsByImageID sync.RWMutex
	lockFailJob             sync.RWMutex
	lockGetJobByID          sync.RWMutex
	lockGetJobsByImageID    sync.RWMutex
	lockGetPendingJobs      sync.RWMutex
	lockStartJob            sync.RWMutex
	lockUpdateJobStatus     sync.RWMutex
}

// CompleteJob calls CompleteJobFunc.
func (mock *RepositoryMock) CompleteJob(ctx context.Context, jobID string) (*queries.Job, error) {
	if mock.CompleteJobFunc == nil {
		panic("RepositoryMock.CompleteJobFunc: method is nil but Repository.CompleteJob was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		JobID string
	}{
		Ctx:   ctx,
		JobID: jobID,
	}
	mock.lockCompleteJob.Lock()
	mock.calls.CompleteJob = append(mock.calls.CompleteJob, callInfo)
	mock.lockCompleteJob.Unlock()
	return mock.CompleteJobFunc(ctx, jobID)
}

// CompleteJobCalls gets all the calls that were made to CompleteJob.
// Check the length with:
//
//	len(mockedRepository.CompleteJobCalls())
func (mock *RepositoryMock) CompleteJobCalls() []struct {
	Ctx   context.Context
	JobID string
} {
	var calls []struct {
		Ctx   context.Context
		JobID string
	}
	mock.lockCompleteJob.RLock()
	calls = mock.calls.CompleteJob
	mock.lockCompleteJob.RUnlock()
	return calls
}

// CreateJob calls CreateJobFunc.
func (mock *RepositoryMock) CreateJob(ctx context.Context, imageID string, jobType string, payloadJSON []byte) (*queries.Job, error) {
	if mock.CreateJobFunc == nil {
		panic("RepositoryMock.CreateJobFunc: method is nil but Repository.CreateJob was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ImageID     string
		JobType     string
		PayloadJSON []byte
	}{
		Ctx:         ctx,
		ImageID:     imageID,
		JobType:     jobType,
		PayloadJSON: payloadJSON,
	}
	mock.lockCreateJob.Lock()
	mock.calls.CreateJob = append(mock.calls.CreateJob, callInfo)
	mock.lockCreateJob.Unlock()
	return mock.CreateJobFunc(ctx, imageID, jobType, payloadJSON)
}

// CreateJobCalls gets all the calls that were made to CreateJob.
// Check the length with:
//
//	len(mockedRepository.CreateJobCalls())
func (mock *RepositoryMock) CreateJobCalls() []struct {
	Ctx         context.Context
	ImageID     string
	JobType     string
	PayloadJSON []byte
} {
	var calls []struct {
		Ctx         context.Context
		ImageID     string
		JobType     string
		PayloadJSON []byte
	}
	mock.lockCreateJob.RLock()
	calls = mock.calls.CreateJob
	mock.lockCreateJob.RUnlock()
	return calls
}

// DeleteJob calls DeleteJobFunc.
func (mock *RepositoryMock) DeleteJob(ctx context.Context, jobID string) error {
	if mock.DeleteJobFunc == nil {
		panic("RepositoryMock.DeleteJobFunc: method is nil but Repository.DeleteJob was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		JobID string
	}{
		Ctx:   ctx,
		JobID: jobID,
	}
	mock.lockDeleteJob.Lock()
	mock.calls.DeleteJob = append(mock.calls.DeleteJob, callInfo)
	mock.lockDeleteJob.Unlock()
	return mock.DeleteJobFunc(ctx, jobID)
}

// DeleteJobCalls gets all the calls that were made to DeleteJob.
// Check the length with:
//
//	len(mockedRepository.DeleteJobCalls())
func (mock *RepositoryMock) DeleteJobCalls() []struct {
	Ctx   context.Context
	JobID string
} {
	var calls []struct {
		Ctx   context.Context
		JobID string
	}
	mock.lockDeleteJob.RLock()
	calls = mock.calls.DeleteJob
	mock.lockDeleteJob.RUnlock()
	return calls
}

// DeleteJobsByImageID calls DeleteJobsByImageIDFunc.
func (mock *RepositoryMock) DeleteJobsByImageID(ctx context.Context, imageID string) error {
	if mock.DeleteJobsByImageIDFunc == nil {
		panic("RepositoryMock.DeleteJobsByImageIDFunc: method is nil but Repository.DeleteJobsByImageID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ImageID string
	}{
		Ctx:     ctx,
		ImageID: imageID,
	}
	mock.lockDeleteJobsByImageID.Lock()
	mock.calls.DeleteJobsByImageID = append(mock.calls.DeleteJobsByImageID, callInfo)
	mock.lockDeleteJobsByImageID.Unlock()
	return mock.DeleteJobsByImageIDFunc(ctx, imageID)
}

// DeleteJobsByImageIDCalls gets all the calls that were made to DeleteJobsByImageID.
// Check the length with:
//
//	len(mockedRepository.DeleteJobsByImageIDCalls())
func (mock *RepositoryMock) DeleteJobsByImageIDCalls() []struct {
	Ctx     context.Context
	ImageID string
} {
	var calls []struct {
		Ctx     context.Context
		ImageID string
	}
	mock.lockDeleteJobsByImageID.RLock()
	calls = mock.calls.DeleteJobsByImageID
	mock.lockDeleteJobsByImageID.RUnlock()
	return calls
}

// FailJob calls FailJobFunc.
func (mock *RepositoryMock) FailJob(ctx context.Context, jobID string, errorMsg string) (*queries.Job, error) {
	if mock.FailJobFunc == nil {
		panic("RepositoryMock.FailJobFunc: method is nil but Repository.FailJob was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		JobID    string
		ErrorMsg string
	}{
		Ctx:      ctx,
		JobID:    jobID,
		ErrorMsg: errorMsg,
	}
	mock.lockFailJob.Lock()
	mock.calls.FailJob = append(mock.calls.FailJob, callInfo)
	mock.lockFailJob.Unlock()
	return mock.FailJobFunc(ctx, jobID, errorMsg)
}

// FailJobCalls gets all the calls that were made to FailJob.
// Check the length with:
//
//	len(mockedRepository.FailJobCalls())
func (mock *RepositoryMock) FailJobCalls() []struct {
	Ctx      context.Context
	JobID    string
	ErrorMsg string
} {
	var calls []struct {
		Ctx      context.Context
		JobID    string
		ErrorMsg string
	}
	mock.lockFailJob.RLock()
	calls = mock.calls.FailJob
	mock.lockFailJob.RUnlock()
	return calls
}

// GetJobByID calls GetJobByIDFunc.
func (mock *RepositoryMock) GetJobByID(ctx context.Context, jobID string) (*queries.Job, error) {
	if mock.GetJobByIDFunc == nil {
		panic("RepositoryMock.GetJobByIDFunc: method is nil but Repository.GetJobByID was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		JobID string
	}{
		Ctx:   ctx,
		JobID: jobID,
	}
	mock.lockGetJobByID.Lock()
	mock.calls.GetJobByID = append(mock.calls.GetJobByID, callInfo)
	mock.lockGetJobByID.Unlock()
	return mock.GetJobByIDFunc(ctx, jobID)
}

// GetJobByIDCalls gets all the calls that were made to GetJobByID.
// Check the length with:
//
//	len(mockedRepository.GetJobByIDCalls())
func (mock *RepositoryMock) GetJobByIDCalls() []struct {
	Ctx   context.Context
	JobID string
} {
	var calls []struct {
		Ctx   context.Context
		JobID string
	}
	mock.lockGetJobByID.RLock()
	calls = mock.calls.GetJobByID
	mock.lockGetJobByID.RUnlock()
	return calls
}

// GetJobsByImageID calls GetJobsByImageIDFunc.
func (mock *RepositoryMock) GetJobsByImageID(ctx context.Context, imageID string) ([]*queries.Job, error) {
	if mock.GetJobsByImageIDFunc == nil {
		panic("RepositoryMock.GetJobsByImageIDFunc: method is nil but Repository.GetJobsByImageID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ImageID string
	}{
		Ctx:     ctx,
		ImageID: imageID,
	}
	mock.lockGetJobsByImageID.Lock()
	mock.calls.GetJobsByImageID = append(mock.calls.GetJobsByImageID, callInfo)
	mock.lockGetJobsByImageID.Unlock()
	return mock.GetJobsByImageIDFunc(ctx, imageID)
}

// GetJobsByImageIDCalls gets all the calls that were made to GetJobsByImageID.
// Check the length with:
//
//	len(mockedRepository.GetJobsByImageIDCalls())
func (mock *RepositoryMock) GetJobsByImageIDCalls() []struct {
	Ctx     context.Context
	ImageID string
} {
	var calls []struct {
		Ctx     context.Context
		ImageID string
	}
	mock.lockGetJobsByImageID.RLock()
	calls = mock.calls.GetJobsByImageID
	mock.lockGetJobsByImageID.RUnlock()
	return calls
}

// GetPendingJobs calls GetPendingJobsFunc.
func (mock *RepositoryMock) GetPendingJobs(ctx context.Context, limit int) ([]*queries.Job, error) {
	if mock.GetPendingJobsFunc == nil {
		panic("RepositoryMock.GetPendingJobsFunc: method is nil but Repository.GetPendingJobs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockGetPendingJobs.Lock()
	mock.calls.GetPendingJobs = append(mock.calls.GetPendingJobs, callInfo)
	mock.lockGetPendingJobs.Unlock()
	return mock.GetPendingJobsFunc(ctx, limit)
}

// GetPendingJobsCalls gets all the calls that were made to GetPendingJobs.
// Check the length with:
//
//	len(mockedRepository.GetPendingJobsCalls())
func (mock *RepositoryMock) GetPendingJobsCalls() []struct {
	Ctx   context.Context
	Limit int
} {
	var calls []struct {
		Ctx   context.Context
		Limit int
	}
	mock.lockGetPendingJobs.RLock()
	calls = mock.calls.GetPendingJobs
	mock.lockGetPendingJobs.RUnlock()
	return calls
}

// StartJob calls StartJobFunc.
func (mock *RepositoryMock) StartJob(ctx context.Context, jobID string) (*queries.Job, error) {
	if mock.StartJobFunc == nil {
		panic("RepositoryMock.StartJobFunc: method is nil but Repository.StartJob was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		JobID string
	}{
		Ctx:   ctx,
		JobID: jobID,
	}
	mock.lockStartJob.Lock()
	mock.calls.StartJob = append(mock.calls.StartJob, callInfo)
	mock.lockStartJob.Unlock()
	return mock.StartJobFunc(ctx, jobID)
}

// StartJobCalls gets all the calls that were made to StartJob.
// Check the length with:
//
//	len(mockedRepository.StartJobCalls())
func (mock *RepositoryMock) StartJobCalls() []struct {
	Ctx   context.Context
	JobID string
} {
	var calls []struct {
		Ctx   context.Context
		JobID string
	}
	mock.lockStartJob.RLock()
	calls = mock.calls.StartJob
	mock.lockStartJob.RUnlock()
	return calls
}

// UpdateJobStatus calls UpdateJobStatusFunc.
func (mock *RepositoryMock) UpdateJobStatus(ctx context.Context, jobID string, status string) (*queries.Job, error) {
	if mock.UpdateJobStatusFunc == nil {
		panic("RepositoryMock.UpdateJobStatusFunc: method is nil but Repository.UpdateJobStatus was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		JobID  string
		Status string
	}{
		Ctx:    ctx,
		JobID:  jobID,
		Status: status,
	}
	mock.lockUpdateJobStatus.Lock()
	mock.calls.UpdateJobStatus = append(mock.calls.UpdateJobStatus, callInfo)
	mock.lockUpdateJobStatus.Unlock()
	return mock.UpdateJobStatusFunc(ctx, jobID, status)
}

// UpdateJobStatusCalls gets all the calls that were made to UpdateJobStatus.
// Check the length with:
//
//	len(mockedRepository.UpdateJobStatusCalls())
func (mock *RepositoryMock) UpdateJobStatusCalls() []struct {
	Ctx    context.Context
	JobID  string
	Status string
} {
	var calls []struct {
		Ctx    context.Context
		JobID  string
		Status string
	}
	mock.lockUpdateJobStatus.RLock()
	calls = mock.calls.UpdateJobStatus
	mock.lockUpdateJobStatus.RUnlock()
	return calls
}
