// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package image

import (
	"context"
	"github.com/virtual-staging-ai/api/internal/storage/queries"
	"sync"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			CreateImageFunc: func(ctx context.Context, projectID string, originalURL string, roomType *string, style *string, seed *int64) (*queries.Image, error) {
//				panic("mock out the CreateImage method")
//			},
//			DeleteImageFunc: func(ctx context.Context, imageID string) error {
//				panic("mock out the DeleteImage method")
//			},
//			DeleteImagesByProjectIDFunc: func(ctx context.Context, projectID string) error {
//				panic("mock out the DeleteImagesByProjectID method")
//			},
//			GetImageByIDFunc: func(ctx context.Context, imageID string) (*queries.Image, error) {
//				panic("mock out the GetImageByID method")
//			},
//			GetImagesByProjectIDFunc: func(ctx context.Context, projectID string) ([]*queries.Image, error) {
//				panic("mock out the GetImagesByProjectID method")
//			},
//			UpdateImageStatusFunc: func(ctx context.Context, imageID string, status string) (*queries.Image, error) {
//				panic("mock out the UpdateImageStatus method")
//			},
//			UpdateImageWithErrorFunc: func(ctx context.Context, imageID string, errorMsg string) (*queries.Image, error) {
//				panic("mock out the UpdateImageWithError method")
//			},
//			UpdateImageWithStagedURLFunc: func(ctx context.Context, imageID string, stagedURL string, status string) (*queries.Image, error) {
//				panic("mock out the UpdateImageWithStagedURL method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// CreateImageFunc mocks the CreateImage method.
	CreateImageFunc func(ctx context.Context, projectID string, originalURL string, roomType *string, style *string, seed *int64) (*queries.Image, error)

	// DeleteImageFunc mocks the DeleteImage method.
	DeleteImageFunc func(ctx context.Context, imageID string) error

	// DeleteImagesByProjectIDFunc mocks the DeleteImagesByProjectID method.
	DeleteImagesByProjectIDFunc func(ctx context.Context, projectID string) error

	// GetImageByIDFunc mocks the GetImageByID method.
	GetImageByIDFunc func(ctx context.Context, imageID string) (*queries.Image, error)

	// GetImagesByProjectIDFunc mocks the GetImagesByProjectID method.
	GetImagesByProjectIDFunc func(ctx context.Context, projectID string) ([]*queries.Image, error)

	// UpdateImageStatusFunc mocks the UpdateImageStatus method.
	UpdateImageStatusFunc func(ctx context.Context, imageID string, status string) (*queries.Image, error)

	// UpdateImageWithErrorFunc mocks the UpdateImageWithError method.
	UpdateImageWithErrorFunc func(ctx context.Context, imageID string, errorMsg string) (*queries.Image, error)

	// UpdateImageWithStagedURLFunc mocks the UpdateImageWithStagedURL method.
	UpdateImageWithStagedURLFunc func(ctx context.Context, imageID string, stagedURL string, status string) (*queries.Image, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateImage holds details about calls to the CreateImage method.
		CreateImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
			// OriginalURL is the originalURL argument value.
			OriginalURL string
			// RoomType is the roomType argument value.
			RoomType *string
			// Style is the style argument value.
			Style *string
			// Seed is the seed argument value.
			Seed *int64
		}
		// DeleteImage holds details about calls to the DeleteImage method.
		DeleteImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID string
		}
		// DeleteImagesByProjectID holds details about calls to the DeleteImagesByProjectID method.
		DeleteImagesByProjectID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
		}
		// GetImageByID holds details about calls to the GetImageByID method.
		GetImageByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID string
		}
		// GetImagesByProjectID holds details about calls to the GetImagesByProjectID method.
		GetImagesByProjectID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
		}
		// UpdateImageStatus holds details about calls to the UpdateImageStatus method.
		UpdateImageStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID string
			// Status is the status argument value.
			Status string
		}
		// UpdateImageWithError holds details about calls to the UpdateImageWithError method.
		UpdateImageWithError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID string
			// ErrorMsg is the errorMsg argument value.
			ErrorMsg string
		}
		// UpdateImageWithStagedURL holds details about calls to the UpdateImageWithStagedURL method.
		UpdateImageWithStagedURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID string
			// StagedURL is the stagedURL argument value.
			StagedURL string
			// Status is the status argument value.
			Status string
		}
	}
	lockCreateImage              sync.RWMutex
	lockDeleteImage              sync.RWMutex
	lockDeleteImagesByProjectID  sync.RWMutex
	lockGetImageByID             sync.RWMutex
	lockGetImagesByProjectID     sync.RWMutex
	lockUpdateImageStatus        sync.RWMutex
	lockUpdateImageWithError     sync.RWMutex
	lockUpdateImageWithStagedURL sync.RWMutex
}

// CreateImage calls CreateImageFunc.
func (mock *RepositoryMock) CreateImage(ctx context.Context, projectID string, originalURL string, roomType *string, style *string, seed *int64) (*queries.Image, error) {
	if mock.CreateImageFunc == nil {
		panic("RepositoryMock.CreateImageFunc: method is nil but Repository.CreateImage was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		ProjectID   string
		OriginalURL string
		RoomType    *string
		Style       *string
		Seed        *int64
	}{
		Ctx:         ctx,
		ProjectID:   projectID,
		OriginalURL: originalURL,
		RoomType:    roomType,
		Style:       style,
		Seed:        seed,
	}
	mock.lockCreateImage.Lock()
	mock.calls.CreateImage = append(mock.calls.CreateImage, callInfo)
	mock.lockCreateImage.Unlock()
	return mock.CreateImageFunc(ctx, projectID, originalURL, roomType, style, seed)
}

// CreateImageCalls gets all the calls that were made to CreateImage.
// Check the length with:
//
//	len(mockedRepository.CreateImageCalls())
func (mock *RepositoryMock) CreateImageCalls() []struct {
	Ctx         context.Context
	ProjectID   string
	OriginalURL string
	RoomType    *string
	Style       *string
	Seed        *int64
} {
	var calls []struct {
		Ctx         context.Context
		ProjectID   string
		OriginalURL string
		RoomType    *string
		Style       *string
		Seed        *int64
	}
	mock.lockCreateImage.RLock()
	calls = mock.calls.CreateImage
	mock.lockCreateImage.RUnlock()
	return calls
}

// DeleteImage calls DeleteImageFunc.
func (mock *RepositoryMock) DeleteImage(ctx context.Context, imageID string) error {
	if mock.DeleteImageFunc == nil {
		panic("RepositoryMock.DeleteImageFunc: method is nil but Repository.DeleteImage was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ImageID string
	}{
		Ctx:     ctx,
		ImageID: imageID,
	}
	mock.lockDeleteImage.Lock()
	mock.calls.DeleteImage = append(mock.calls.DeleteImage, callInfo)
	mock.lockDeleteImage.Unlock()
	return mock.DeleteImageFunc(ctx, imageID)
}

// DeleteImageCalls gets all the calls that were made to DeleteImage.
// Check the length with:
//
//	len(mockedRepository.DeleteImageCalls())
func (mock *RepositoryMock) DeleteImageCalls() []struct {
	Ctx     context.Context
	ImageID string
} {
	var calls []struct {
		Ctx     context.Context
		ImageID string
	}
	mock.lockDeleteImage.RLock()
	calls = mock.calls.DeleteImage
	mock.lockDeleteImage.RUnlock()
	return calls
}

// DeleteImagesByProjectID calls DeleteImagesByProjectIDFunc.
func (mock *RepositoryMock) DeleteImagesByProjectID(ctx context.Context, projectID string) error {
	if mock.DeleteImagesByProjectIDFunc == nil {
		panic("RepositoryMock.DeleteImagesByProjectIDFunc: method is nil but Repository.DeleteImagesByProjectID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID string
	}{
		Ctx:       ctx,
		ProjectID: projectID,
	}
	mock.lockDeleteImagesByProjectID.Lock()
	mock.calls.DeleteImagesByProjectID = append(mock.calls.DeleteImagesByProjectID, callInfo)
	mock.lockDeleteImagesByProjectID.Unlock()
	return mock.DeleteImagesByProjectIDFunc(ctx, projectID)
}

// DeleteImagesByProjectIDCalls gets all the calls that were made to DeleteImagesByProjectID.
// Check the length with:
//
//	len(mockedRepository.DeleteImagesByProjectIDCalls())
func (mock *RepositoryMock) DeleteImagesByProjectIDCalls() []struct {
	Ctx       context.Context
	ProjectID string
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID string
	}
	mock.lockDeleteImagesByProjectID.RLock()
	calls = mock.calls.DeleteImagesByProjectID
	mock.lockDeleteImagesByProjectID.RUnlock()
	return calls
}

// GetImageByID calls GetImageByIDFunc.
func (mock *RepositoryMock) GetImageByID(ctx context.Context, imageID string) (*queries.Image, error) {
	if mock.GetImageByIDFunc == nil {
		panic("RepositoryMock.GetImageByIDFunc: method is nil but Repository.GetImageByID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ImageID string
	}{
		Ctx:     ctx,
		ImageID: imageID,
	}
	mock.lockGetImageByID.Lock()
	mock.calls.GetImageByID = append(mock.calls.GetImageByID, callInfo)
	mock.lockGetImageByID.Unlock()
	return mock.GetImageByIDFunc(ctx, imageID)
}

// GetImageByIDCalls gets all the calls that were made to GetImageByID.
// Check the length with:
//
//	len(mockedRepository.GetImageByIDCalls())
func (mock *RepositoryMock) GetImageByIDCalls() []struct {
	Ctx     context.Context
	ImageID string
} {
	var calls []struct {
		Ctx     context.Context
		ImageID string
	}
	mock.lockGetImageByID.RLock()
	calls = mock.calls.GetImageByID
	mock.lockGetImageByID.RUnlock()
	return calls
}

// GetImagesByProjectID calls GetImagesByProjectIDFunc.
func (mock *RepositoryMock) GetImagesByProjectID(ctx context.Context, projectID string) ([]*queries.Image, error) {
	if mock.GetImagesByProjectIDFunc == nil {
		panic("RepositoryMock.GetImagesByProjectIDFunc: method is nil but Repository.GetImagesByProjectID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID string
	}{
		Ctx:       ctx,
		ProjectID: projectID,
	}
	mock.lockGetImagesByProjectID.Lock()
	mock.calls.GetImagesByProjectID = append(mock.calls.GetImagesByProjectID, callInfo)
	mock.lockGetImagesByProjectID.Unlock()
	return mock.GetImagesByProjectIDFunc(ctx, projectID)
}

// GetImagesByProjectIDCalls gets all the calls that were made to GetImagesByProjectID.
// Check the length with:
//
//	len(mockedRepository.GetImagesByProjectIDCalls())
func (mock *RepositoryMock) GetImagesByProjectIDCalls() []struct {
	Ctx       context.Context
	ProjectID string
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID string
	}
	mock.lockGetImagesByProjectID.RLock()
	calls = mock.calls.GetImagesByProjectID
	mock.lockGetImagesByProjectID.RUnlock()
	return calls
}

// UpdateImageStatus calls UpdateImageStatusFunc.
func (mock *RepositoryMock) UpdateImageStatus(ctx context.Context, imageID string, status string) (*queries.Image, error) {
	if mock.UpdateImageStatusFunc == nil {
		panic("RepositoryMock.UpdateImageStatusFunc: method is nil but Repository.UpdateImageStatus was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ImageID string
		Status  string
	}{
		Ctx:     ctx,
		ImageID: imageID,
		Status:  status,
	}
	mock.lockUpdateImageStatus.Lock()
	mock.calls.UpdateImageStatus = append(mock.calls.UpdateImageStatus, callInfo)
	mock.lockUpdateImageStatus.Unlock()
	return mock.UpdateImageStatusFunc(ctx, imageID, status)
}

// UpdateImageStatusCalls gets all the calls that were made to UpdateImageStatus.
// Check the length with:
//
//	len(mockedRepository.UpdateImageStatusCalls())
func (mock *RepositoryMock) UpdateImageStatusCalls() []struct {
	Ctx     context.Context
	ImageID string
	Status  string
} {
	var calls []struct {
		Ctx     context.Context
		ImageID string
		Status  string
	}
	mock.lockUpdateImageStatus.RLock()
	calls = mock.calls.UpdateImageStatus
	mock.lockUpdateImageStatus.RUnlock()
	return calls
}

// UpdateImageWithError calls UpdateImageWithErrorFunc.
func (mock *RepositoryMock) UpdateImageWithError(ctx context.Context, imageID string, errorMsg string) (*queries.Image, error) {
	if mock.UpdateImageWithErrorFunc == nil {
		panic("RepositoryMock.UpdateImageWithErrorFunc: method is nil but Repository.UpdateImageWithError was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		ImageID  string
		ErrorMsg string
	}{
		Ctx:      ctx,
		ImageID:  imageID,
		ErrorMsg: errorMsg,
	}
	mock.lockUpdateImageWithError.Lock()
	mock.calls.UpdateImageWithError = append(mock.calls.UpdateImageWithError, callInfo)
	mock.lockUpdateImageWithError.Unlock()
	return mock.UpdateImageWithErrorFunc(ctx, imageID, errorMsg)
}

// UpdateImageWithErrorCalls gets all the calls that were made to UpdateImageWithError.
// Check the length with:
//
//	len(mockedRepository.UpdateImageWithErrorCalls())
func (mock *RepositoryMock) UpdateImageWithErrorCalls() []struct {
	Ctx      context.Context
	ImageID  string
	ErrorMsg string
} {
	var calls []struct {
		Ctx      context.Context
		ImageID  string
		ErrorMsg string
	}
	mock.lockUpdateImageWithError.RLock()
	calls = mock.calls.UpdateImageWithError
	mock.lockUpdateImageWithError.RUnlock()
	return calls
}

// UpdateImageWithStagedURL calls UpdateImageWithStagedURLFunc.
func (mock *RepositoryMock) UpdateImageWithStagedURL(ctx context.Context, imageID string, stagedURL string, status string) (*queries.Image, error) {
	if mock.UpdateImageWithStagedURLFunc == nil {
		panic("RepositoryMock.UpdateImageWithStagedURLFunc: method is nil but Repository.UpdateImageWithStagedURL was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ImageID   string
		StagedURL string
		Status    string
	}{
		Ctx:       ctx,
		ImageID:   imageID,
		StagedURL: stagedURL,
		Status:    status,
	}
	mock.lockUpdateImageWithStagedURL.Lock()
	mock.calls.UpdateImageWithStagedURL = append(mock.calls.UpdateImageWithStagedURL, callInfo)
	mock.lockUpdateImageWithStagedURL.Unlock()
	return mock.UpdateImageWithStagedURLFunc(ctx, imageID, stagedURL, status)
}

// UpdateImageWithStagedURLCalls gets all the calls that were made to UpdateImageWithStagedURL.
// Check the length with:
//
//	len(mockedRepository.UpdateImageWithStagedURLCalls())
func (mock *RepositoryMock) UpdateImageWithStagedURLCalls() []struct {
	Ctx       context.Context
	ImageID   string
	StagedURL string
	Status    string
} {
	var calls []struct {
		Ctx       context.Context
		ImageID   string
		StagedURL string
		Status    string
	}
	mock.lockUpdateImageWithStagedURL.RLock()
	calls = mock.calls.UpdateImageWithStagedURL
	mock.lockUpdateImageWithStagedURL.RUnlock()
	return calls
}
