// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package project

import (
	"context"
	"sync"
)

// Ensure, that StorageMock does implement Storage.
// If this is not the case, regenerate this file with moq.
var _ Storage = &StorageMock{}

// StorageMock is a mock implementation of Storage.
//
//	func TestSomethingThatUsesStorage(t *testing.T) {
//
//		// make and configure a mocked Storage
//		mockedStorage := &StorageMock{
//			CountProjectsByUserIDFunc: func(ctx context.Context, userID string) (int64, error) {
//				panic("mock out the CountProjectsByUserID method")
//			},
//			CreateProjectFunc: func(ctx context.Context, p *Project, userID string) (*Project, error) {
//				panic("mock out the CreateProject method")
//			},
//			DeleteProjectFunc: func(ctx context.Context, projectID string) error {
//				panic("mock out the DeleteProject method")
//			},
//			DeleteProjectByUserIDFunc: func(ctx context.Context, projectID string, userID string) error {
//				panic("mock out the DeleteProjectByUserID method")
//			},
//			GetProjectByIDFunc: func(ctx context.Context, projectID string) (*Project, error) {
//				panic("mock out the GetProjectByID method")
//			},
//			GetProjectByIDAndUserIDFunc: func(ctx context.Context, projectID string, userID string) (*Project, error) {
//				panic("mock out the GetProjectByIDAndUserID method")
//			},
//			GetProjectsFunc: func(ctx context.Context) ([]Project, error) {
//				panic("mock out the GetProjects method")
//			},
//			GetProjectsByUserIDFunc: func(ctx context.Context, userID string) ([]Project, error) {
//				panic("mock out the GetProjectsByUserID method")
//			},
//			UpdateProjectFunc: func(ctx context.Context, projectID string, name string) (*Project, error) {
//				panic("mock out the UpdateProject method")
//			},
//			UpdateProjectByUserIDFunc: func(ctx context.Context, projectID string, userID string, name string) (*Project, error) {
//				panic("mock out the UpdateProjectByUserID method")
//			},
//		}
//
//		// use mockedStorage in code that requires Storage
//		// and then make assertions.
//
//	}
type StorageMock struct {
	// CountProjectsByUserIDFunc mocks the CountProjectsByUserID method.
	CountProjectsByUserIDFunc func(ctx context.Context, userID string) (int64, error)

	// CreateProjectFunc mocks the CreateProject method.
	CreateProjectFunc func(ctx context.Context, p *Project, userID string) (*Project, error)

	// DeleteProjectFunc mocks the DeleteProject method.
	DeleteProjectFunc func(ctx context.Context, projectID string) error

	// DeleteProjectByUserIDFunc mocks the DeleteProjectByUserID method.
	DeleteProjectByUserIDFunc func(ctx context.Context, projectID string, userID string) error

	// GetProjectByIDFunc mocks the GetProjectByID method.
	GetProjectByIDFunc func(ctx context.Context, projectID string) (*Project, error)

	// GetProjectByIDAndUserIDFunc mocks the GetProjectByIDAndUserID method.
	GetProjectByIDAndUserIDFunc func(ctx context.Context, projectID string, userID string) (*Project, error)

	// GetProjectsFunc mocks the GetProjects method.
	GetProjectsFunc func(ctx context.Context) ([]Project, error)

	// GetProjectsByUserIDFunc mocks the GetProjectsByUserID method.
	GetProjectsByUserIDFunc func(ctx context.Context, userID string) ([]Project, error)

	// UpdateProjectFunc mocks the UpdateProject method.
	UpdateProjectFunc func(ctx context.Context, projectID string, name string) (*Project, error)

	// UpdateProjectByUserIDFunc mocks the UpdateProjectByUserID method.
	UpdateProjectByUserIDFunc func(ctx context.Context, projectID string, userID string, name string) (*Project, error)

	// calls tracks calls to the methods.
	calls struct {
		// CountProjectsByUserID holds details about calls to the CountProjectsByUserID method.
		CountProjectsByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
		}
		// CreateProject holds details about calls to the CreateProject method.
		CreateProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// P is the p argument value.
			P *Project
			// UserID is the userID argument value.
			UserID string
		}
		// DeleteProject holds details about calls to the DeleteProject method.
		DeleteProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
		}
		// DeleteProjectByUserID holds details about calls to the DeleteProjectByUserID method.
		DeleteProjectByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
			// UserID is the userID argument value.
			UserID string
		}
		// GetProjectByID holds details about calls to the GetProjectByID method.
		GetProjectByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
		}
		// GetProjectByIDAndUserID holds details about calls to the GetProjectByIDAndUserID method.
		GetProjectByIDAndUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
			// UserID is the userID argument value.
			UserID string
		}
		// GetProjects holds details about calls to the GetProjects method.
		GetProjects []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetProjectsByUserID holds details about calls to the GetProjectsByUserID method.
		GetProjectsByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID string
		}
		// UpdateProject holds details about calls to the UpdateProject method.
		UpdateProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
			// Name is the name argument value.
			Name string
		}
		// UpdateProjectByUserID holds details about calls to the UpdateProjectByUserID method.
		UpdateProjectByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID string
			// UserID is the userID argument value.
			UserID string
			// Name is the name argument value.
			Name string
		}
	}
	lockCountProjectsByUserID   sync.RWMutex
	lockCreateProject           sync.RWMutex
	lockDeleteProject           sync.RWMutex
	lockDeleteProjectByUserID   sync.RWMutex
	lockGetProjectByID          sync.RWMutex
	lockGetProjectByIDAndUserID sync.RWMutex
	lockGetProjects             sync.RWMutex
	lockGetProjectsByUserID     sync.RWMutex
	lockUpdateProject           sync.RWMutex
	lockUpdateProjectByUserID   sync.RWMutex
}

// CountProjectsByUserID calls CountProjectsByUserIDFunc.
func (mock *StorageMock) CountProjectsByUserID(ctx context.Context, userID string) (int64, error) {
	if mock.CountProjectsByUserIDFunc == nil {
		panic("StorageMock.CountProjectsByUserIDFunc: method is nil but Storage.CountProjectsByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockCountProjectsByUserID.Lock()
	mock.calls.CountProjectsByUserID = append(mock.calls.CountProjectsByUserID, callInfo)
	mock.lockCountProjectsByUserID.Unlock()
	return mock.CountProjectsByUserIDFunc(ctx, userID)
}

// CountProjectsByUserIDCalls gets all the calls that were made to CountProjectsByUserID.
// Check the length with:
//
//	len(mockedStorage.CountProjectsByUserIDCalls())
func (mock *StorageMock) CountProjectsByUserIDCalls() []struct {
	Ctx    context.Context
	UserID string
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
	}
	mock.lockCountProjectsByUserID.RLock()
	calls = mock.calls.CountProjectsByUserID
	mock.lockCountProjectsByUserID.RUnlock()
	return calls
}

// CreateProject calls CreateProjectFunc.
func (mock *StorageMock) CreateProject(ctx context.Context, p *Project, userID string) (*Project, error) {
	if mock.CreateProjectFunc == nil {
		panic("StorageMock.CreateProjectFunc: method is nil but Storage.CreateProject was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		P      *Project
		UserID string
	}{
		Ctx:    ctx,
		P:      p,
		UserID: userID,
	}
	mock.lockCreateProject.Lock()
	mock.calls.CreateProject = append(mock.calls.CreateProject, callInfo)
	mock.lockCreateProject.Unlock()
	return mock.CreateProjectFunc(ctx, p, userID)
}

// CreateProjectCalls gets all the calls that were made to CreateProject.
// Check the length with:
//
//	len(mockedStorage.CreateProjectCalls())
func (mock *StorageMock) CreateProjectCalls() []struct {
	Ctx    context.Context
	P      *Project
	UserID string
} {
	var calls []struct {
		Ctx    context.Context
		P      *Project
		UserID string
	}
	mock.lockCreateProject.RLock()
	calls = mock.calls.CreateProject
	mock.lockCreateProject.RUnlock()
	return calls
}

// DeleteProject calls DeleteProjectFunc.
func (mock *StorageMock) DeleteProject(ctx context.Context, projectID string) error {
	if mock.DeleteProjectFunc == nil {
		panic("StorageMock.DeleteProjectFunc: method is nil but Storage.DeleteProject was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID string
	}{
		Ctx:       ctx,
		ProjectID: projectID,
	}
	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = append(mock.calls.DeleteProject, callInfo)
	mock.lockDeleteProject.Unlock()
	return mock.DeleteProjectFunc(ctx, projectID)
}

// DeleteProjectCalls gets all the calls that were made to DeleteProject.
// Check the length with:
//
//	len(mockedStorage.DeleteProjectCalls())
func (mock *StorageMock) DeleteProjectCalls() []struct {
	Ctx       context.Context
	ProjectID string
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID string
	}
	mock.lockDeleteProject.RLock()
	calls = mock.calls.DeleteProject
	mock.lockDeleteProject.RUnlock()
	return calls
}

// DeleteProjectByUserID calls DeleteProjectByUserIDFunc.
func (mock *StorageMock) DeleteProjectByUserID(ctx context.Context, projectID string, userID string) error {
	if mock.DeleteProjectByUserIDFunc == nil {
		panic("StorageMock.DeleteProjectByUserIDFunc: method is nil but Storage.DeleteProjectByUserID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID string
		UserID    string
	}{
		Ctx:       ctx,
		ProjectID: projectID,
		UserID:    userID,
	}
	mock.lockDeleteProjectByUserID.Lock()
	mock.calls.DeleteProjectByUserID = append(mock.calls.DeleteProjectByUserID, callInfo)
	mock.lockDeleteProjectByUserID.Unlock()
	return mock.DeleteProjectByUserIDFunc(ctx, projectID, userID)
}

// DeleteProjectByUserIDCalls gets all the calls that were made to DeleteProjectByUserID.
// Check the length with:
//
//	len(mockedStorage.DeleteProjectByUserIDCalls())
func (mock *StorageMock) DeleteProjectByUserIDCalls() []struct {
	Ctx       context.Context
	ProjectID string
	UserID    string
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID string
		UserID    string
	}
	mock.lockDeleteProjectByUserID.RLock()
	calls = mock.calls.DeleteProjectByUserID
	mock.lockDeleteProjectByUserID.RUnlock()
	return calls
}

// GetProjectByID calls GetProjectByIDFunc.
func (mock *StorageMock) GetProjectByID(ctx context.Context, projectID string) (*Project, error) {
	if mock.GetProjectByIDFunc == nil {
		panic("StorageMock.GetProjectByIDFunc: method is nil but Storage.GetProjectByID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID string
	}{
		Ctx:       ctx,
		ProjectID: projectID,
	}
	mock.lockGetProjectByID.Lock()
	mock.calls.GetProjectByID = append(mock.calls.GetProjectByID, callInfo)
	mock.lockGetProjectByID.Unlock()
	return mock.GetProjectByIDFunc(ctx, projectID)
}

// GetProjectByIDCalls gets all the calls that were made to GetProjectByID.
// Check the length with:
//
//	len(mockedStorage.GetProjectByIDCalls())
func (mock *StorageMock) GetProjectByIDCalls() []struct {
	Ctx       context.Context
	ProjectID string
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID string
	}
	mock.lockGetProjectByID.RLock()
	calls = mock.calls.GetProjectByID
	mock.lockGetProjectByID.RUnlock()
	return calls
}

// GetProjectByIDAndUserID calls GetProjectByIDAndUserIDFunc.
func (mock *StorageMock) GetProjectByIDAndUserID(ctx context.Context, projectID string, userID string) (*Project, error) {
	if mock.GetProjectByIDAndUserIDFunc == nil {
		panic("StorageMock.GetProjectByIDAndUserIDFunc: method is nil but Storage.GetProjectByIDAndUserID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID string
		UserID    string
	}{
		Ctx:       ctx,
		ProjectID: projectID,
		UserID:    userID,
	}
	mock.lockGetProjectByIDAndUserID.Lock()
	mock.calls.GetProjectByIDAndUserID = append(mock.calls.GetProjectByIDAndUserID, callInfo)
	mock.lockGetProjectByIDAndUserID.Unlock()
	return mock.GetProjectByIDAndUserIDFunc(ctx, projectID, userID)
}

// GetProjectByIDAndUserIDCalls gets all the calls that were made to GetProjectByIDAndUserID.
// Check the length with:
//
//	len(mockedStorage.GetProjectByIDAndUserIDCalls())
func (mock *StorageMock) GetProjectByIDAndUserIDCalls() []struct {
	Ctx       context.Context
	ProjectID string
	UserID    string
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID string
		UserID    string
	}
	mock.lockGetProjectByIDAndUserID.RLock()
	calls = mock.calls.GetProjectByIDAndUserID
	mock.lockGetProjectByIDAndUserID.RUnlock()
	return calls
}

// GetProjects calls GetProjectsFunc.
func (mock *StorageMock) GetProjects(ctx context.Context) ([]Project, error) {
	if mock.GetProjectsFunc == nil {
		panic("StorageMock.GetProjectsFunc: method is nil but Storage.GetProjects was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetProjects.Lock()
	mock.calls.GetProjects = append(mock.calls.GetProjects, callInfo)
	mock.lockGetProjects.Unlock()
	return mock.GetProjectsFunc(ctx)
}

// GetProjectsCalls gets all the calls that were made to GetProjects.
// Check the length with:
//
//	len(mockedStorage.GetProjectsCalls())
func (mock *StorageMock) GetProjectsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetProjects.RLock()
	calls = mock.calls.GetProjects
	mock.lockGetProjects.RUnlock()
	return calls
}

// GetProjectsByUserID calls GetProjectsByUserIDFunc.
func (mock *StorageMock) GetProjectsByUserID(ctx context.Context, userID string) ([]Project, error) {
	if mock.GetProjectsByUserIDFunc == nil {
		panic("StorageMock.GetProjectsByUserIDFunc: method is nil but Storage.GetProjectsByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID string
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetProjectsByUserID.Lock()
	mock.calls.GetProjectsByUserID = append(mock.calls.GetProjectsByUserID, callInfo)
	mock.lockGetProjectsByUserID.Unlock()
	return mock.GetProjectsByUserIDFunc(ctx, userID)
}

// GetProjectsByUserIDCalls gets all the calls that were made to GetProjectsByUserID.
// Check the length with:
//
//	len(mockedStorage.GetProjectsByUserIDCalls())
func (mock *StorageMock) GetProjectsByUserIDCalls() []struct {
	Ctx    context.Context
	UserID string
} {
	var calls []struct {
		Ctx    context.Context
		UserID string
	}
	mock.lockGetProjectsByUserID.RLock()
	calls = mock.calls.GetProjectsByUserID
	mock.lockGetProjectsByUserID.RUnlock()
	return calls
}

// UpdateProject calls UpdateProjectFunc.
func (mock *StorageMock) UpdateProject(ctx context.Context, projectID string, name string) (*Project, error) {
	if mock.UpdateProjectFunc == nil {
		panic("StorageMock.UpdateProjectFunc: method is nil but Storage.UpdateProject was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID string
		Name      string
	}{
		Ctx:       ctx,
		ProjectID: projectID,
		Name:      name,
	}
	mock.lockUpdateProject.Lock()
	mock.calls.UpdateProject = append(mock.calls.UpdateProject, callInfo)
	mock.lockUpdateProject.Unlock()
	return mock.UpdateProjectFunc(ctx, projectID, name)
}

// UpdateProjectCalls gets all the calls that were made to UpdateProject.
// Check the length with:
//
//	len(mockedStorage.UpdateProjectCalls())
func (mock *StorageMock) UpdateProjectCalls() []struct {
	Ctx       context.Context
	ProjectID string
	Name      string
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID string
		Name      string
	}
	mock.lockUpdateProject.RLock()
	calls = mock.calls.UpdateProject
	mock.lockUpdateProject.RUnlock()
	return calls
}

// UpdateProjectByUserID calls UpdateProjectByUserIDFunc.
func (mock *StorageMock) UpdateProjectByUserID(ctx context.Context, projectID string, userID string, name string) (*Project, error) {
	if mock.UpdateProjectByUserIDFunc == nil {
		panic("StorageMock.UpdateProjectByUserIDFunc: method is nil but Storage.UpdateProjectByUserID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID string
		UserID    string
		Name      string
	}{
		Ctx:       ctx,
		ProjectID: projectID,
		UserID:    userID,
		Name:      name,
	}
	mock.lockUpdateProjectByUserID.Lock()
	mock.calls.UpdateProjectByUserID = append(mock.calls.UpdateProjectByUserID, callInfo)
	mock.lockUpdateProjectByUserID.Unlock()
	return mock.UpdateProjectByUserIDFunc(ctx, projectID, userID, name)
}

// UpdateProjectByUserIDCalls gets all the calls that were made to UpdateProjectByUserID.
// Check the length with:
//
//	len(mockedStorage.UpdateProjectByUserIDCalls())
func (mock *StorageMock) UpdateProjectByUserIDCalls() []struct {
	Ctx       context.Context
	ProjectID string
	UserID    string
	Name      string
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID string
		UserID    string
		Name      string
	}
	mock.lockUpdateProjectByUserID.RLock()
	calls = mock.calls.UpdateProjectByUserID
	mock.lockUpdateProjectByUserID.RUnlock()
	return calls
}
