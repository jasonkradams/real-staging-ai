// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package queries

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"sync"
)

// Ensure, that QuerierMock does implement Querier.
// If this is not the case, regenerate this file with moq.
var _ Querier = &QuerierMock{}

// QuerierMock is a mock implementation of Querier.
//
//	func TestSomethingThatUsesQuerier(t *testing.T) {
//
//		// make and configure a mocked Querier
//		mockedQuerier := &QuerierMock{
//			CompleteJobFunc: func(ctx context.Context, id pgtype.UUID) (*Job, error) {
//				panic("mock out the CompleteJob method")
//			},
//			CountProjectsByUserIDFunc: func(ctx context.Context, userID pgtype.UUID) (int64, error) {
//				panic("mock out the CountProjectsByUserID method")
//			},
//			CountUsersFunc: func(ctx context.Context) (int64, error) {
//				panic("mock out the CountUsers method")
//			},
//			CreateImageFunc: func(ctx context.Context, arg CreateImageParams) (*Image, error) {
//				panic("mock out the CreateImage method")
//			},
//			CreateJobFunc: func(ctx context.Context, arg CreateJobParams) (*Job, error) {
//				panic("mock out the CreateJob method")
//			},
//			CreateProcessedEventFunc: func(ctx context.Context, arg CreateProcessedEventParams) (*ProcessedEvent, error) {
//				panic("mock out the CreateProcessedEvent method")
//			},
//			CreateProjectFunc: func(ctx context.Context, arg CreateProjectParams) (*CreateProjectRow, error) {
//				panic("mock out the CreateProject method")
//			},
//			CreateUserFunc: func(ctx context.Context, arg CreateUserParams) (*User, error) {
//				panic("mock out the CreateUser method")
//			},
//			DeleteImageFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the DeleteImage method")
//			},
//			DeleteImagesByProjectIDFunc: func(ctx context.Context, projectID pgtype.UUID) error {
//				panic("mock out the DeleteImagesByProjectID method")
//			},
//			DeleteJobFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the DeleteJob method")
//			},
//			DeleteJobsByImageIDFunc: func(ctx context.Context, imageID pgtype.UUID) error {
//				panic("mock out the DeleteJobsByImageID method")
//			},
//			DeleteOldProcessedEventsFunc: func(ctx context.Context, receivedAt pgtype.Timestamptz) error {
//				panic("mock out the DeleteOldProcessedEvents method")
//			},
//			DeleteProjectFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the DeleteProject method")
//			},
//			DeleteProjectByUserIDFunc: func(ctx context.Context, arg DeleteProjectByUserIDParams) error {
//				panic("mock out the DeleteProjectByUserID method")
//			},
//			DeleteSubscriptionByStripeIDFunc: func(ctx context.Context, stripeSubscriptionID string) error {
//				panic("mock out the DeleteSubscriptionByStripeID method")
//			},
//			DeleteUserFunc: func(ctx context.Context, id pgtype.UUID) error {
//				panic("mock out the DeleteUser method")
//			},
//			FailJobFunc: func(ctx context.Context, arg FailJobParams) (*Job, error) {
//				panic("mock out the FailJob method")
//			},
//			GetAllProjectsFunc: func(ctx context.Context) ([]*GetAllProjectsRow, error) {
//				panic("mock out the GetAllProjects method")
//			},
//			GetImageByIDFunc: func(ctx context.Context, id pgtype.UUID) (*Image, error) {
//				panic("mock out the GetImageByID method")
//			},
//			GetImagesByProjectIDFunc: func(ctx context.Context, projectID pgtype.UUID) ([]*Image, error) {
//				panic("mock out the GetImagesByProjectID method")
//			},
//			GetInvoiceByStripeIDFunc: func(ctx context.Context, stripeInvoiceID string) (*Invoice, error) {
//				panic("mock out the GetInvoiceByStripeID method")
//			},
//			GetJobByIDFunc: func(ctx context.Context, id pgtype.UUID) (*Job, error) {
//				panic("mock out the GetJobByID method")
//			},
//			GetJobsByImageIDFunc: func(ctx context.Context, imageID pgtype.UUID) ([]*Job, error) {
//				panic("mock out the GetJobsByImageID method")
//			},
//			GetPendingJobsFunc: func(ctx context.Context, limit int32) ([]*Job, error) {
//				panic("mock out the GetPendingJobs method")
//			},
//			GetProcessedEventByStripeIDFunc: func(ctx context.Context, stripeEventID string) (*ProcessedEvent, error) {
//				panic("mock out the GetProcessedEventByStripeID method")
//			},
//			GetProjectByIDFunc: func(ctx context.Context, id pgtype.UUID) (*GetProjectByIDRow, error) {
//				panic("mock out the GetProjectByID method")
//			},
//			GetProjectsByUserIDFunc: func(ctx context.Context, userID pgtype.UUID) ([]*GetProjectsByUserIDRow, error) {
//				panic("mock out the GetProjectsByUserID method")
//			},
//			GetSubscriptionByStripeIDFunc: func(ctx context.Context, stripeSubscriptionID string) (*Subscription, error) {
//				panic("mock out the GetSubscriptionByStripeID method")
//			},
//			GetUserByAuth0SubFunc: func(ctx context.Context, auth0Sub string) (*User, error) {
//				panic("mock out the GetUserByAuth0Sub method")
//			},
//			GetUserByIDFunc: func(ctx context.Context, id pgtype.UUID) (*User, error) {
//				panic("mock out the GetUserByID method")
//			},
//			GetUserByStripeCustomerIDFunc: func(ctx context.Context, stripeCustomerID pgtype.Text) (*User, error) {
//				panic("mock out the GetUserByStripeCustomerID method")
//			},
//			ListImagesForReconcileFunc: func(ctx context.Context, arg ListImagesForReconcileParams) ([]*Image, error) {
//				panic("mock out the ListImagesForReconcile method")
//			},
//			ListInvoicesByUserIDFunc: func(ctx context.Context, arg ListInvoicesByUserIDParams) ([]*Invoice, error) {
//				panic("mock out the ListInvoicesByUserID method")
//			},
//			ListSubscriptionsByUserIDFunc: func(ctx context.Context, arg ListSubscriptionsByUserIDParams) ([]*Subscription, error) {
//				panic("mock out the ListSubscriptionsByUserID method")
//			},
//			ListUsersFunc: func(ctx context.Context, arg ListUsersParams) ([]*User, error) {
//				panic("mock out the ListUsers method")
//			},
//			StartJobFunc: func(ctx context.Context, id pgtype.UUID) (*Job, error) {
//				panic("mock out the StartJob method")
//			},
//			UpdateImageStatusFunc: func(ctx context.Context, arg UpdateImageStatusParams) (*Image, error) {
//				panic("mock out the UpdateImageStatus method")
//			},
//			UpdateImageWithErrorFunc: func(ctx context.Context, arg UpdateImageWithErrorParams) (*Image, error) {
//				panic("mock out the UpdateImageWithError method")
//			},
//			UpdateImageWithStagedURLFunc: func(ctx context.Context, arg UpdateImageWithStagedURLParams) (*Image, error) {
//				panic("mock out the UpdateImageWithStagedURL method")
//			},
//			UpdateJobStatusFunc: func(ctx context.Context, arg UpdateJobStatusParams) (*Job, error) {
//				panic("mock out the UpdateJobStatus method")
//			},
//			UpdateProjectFunc: func(ctx context.Context, arg UpdateProjectParams) (*UpdateProjectRow, error) {
//				panic("mock out the UpdateProject method")
//			},
//			UpdateProjectByUserIDFunc: func(ctx context.Context, arg UpdateProjectByUserIDParams) (*UpdateProjectByUserIDRow, error) {
//				panic("mock out the UpdateProjectByUserID method")
//			},
//			UpdateUserRoleFunc: func(ctx context.Context, arg UpdateUserRoleParams) (*User, error) {
//				panic("mock out the UpdateUserRole method")
//			},
//			UpdateUserStripeCustomerIDFunc: func(ctx context.Context, arg UpdateUserStripeCustomerIDParams) (*User, error) {
//				panic("mock out the UpdateUserStripeCustomerID method")
//			},
//			UpsertInvoiceByStripeIDFunc: func(ctx context.Context, arg UpsertInvoiceByStripeIDParams) (*Invoice, error) {
//				panic("mock out the UpsertInvoiceByStripeID method")
//			},
//			UpsertProcessedEventByStripeIDFunc: func(ctx context.Context, arg UpsertProcessedEventByStripeIDParams) (*ProcessedEvent, error) {
//				panic("mock out the UpsertProcessedEventByStripeID method")
//			},
//			UpsertSubscriptionByStripeIDFunc: func(ctx context.Context, arg UpsertSubscriptionByStripeIDParams) (*Subscription, error) {
//				panic("mock out the UpsertSubscriptionByStripeID method")
//			},
//		}
//
//		// use mockedQuerier in code that requires Querier
//		// and then make assertions.
//
//	}
type QuerierMock struct {
	// CompleteJobFunc mocks the CompleteJob method.
	CompleteJobFunc func(ctx context.Context, id pgtype.UUID) (*Job, error)

	// CountProjectsByUserIDFunc mocks the CountProjectsByUserID method.
	CountProjectsByUserIDFunc func(ctx context.Context, userID pgtype.UUID) (int64, error)

	// CountUsersFunc mocks the CountUsers method.
	CountUsersFunc func(ctx context.Context) (int64, error)

	// CreateImageFunc mocks the CreateImage method.
	CreateImageFunc func(ctx context.Context, arg CreateImageParams) (*Image, error)

	// CreateJobFunc mocks the CreateJob method.
	CreateJobFunc func(ctx context.Context, arg CreateJobParams) (*Job, error)

	// CreateProcessedEventFunc mocks the CreateProcessedEvent method.
	CreateProcessedEventFunc func(ctx context.Context, arg CreateProcessedEventParams) (*ProcessedEvent, error)

	// CreateProjectFunc mocks the CreateProject method.
	CreateProjectFunc func(ctx context.Context, arg CreateProjectParams) (*CreateProjectRow, error)

	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(ctx context.Context, arg CreateUserParams) (*User, error)

	// DeleteImageFunc mocks the DeleteImage method.
	DeleteImageFunc func(ctx context.Context, id pgtype.UUID) error

	// DeleteImagesByProjectIDFunc mocks the DeleteImagesByProjectID method.
	DeleteImagesByProjectIDFunc func(ctx context.Context, projectID pgtype.UUID) error

	// DeleteJobFunc mocks the DeleteJob method.
	DeleteJobFunc func(ctx context.Context, id pgtype.UUID) error

	// DeleteJobsByImageIDFunc mocks the DeleteJobsByImageID method.
	DeleteJobsByImageIDFunc func(ctx context.Context, imageID pgtype.UUID) error

	// DeleteOldProcessedEventsFunc mocks the DeleteOldProcessedEvents method.
	DeleteOldProcessedEventsFunc func(ctx context.Context, receivedAt pgtype.Timestamptz) error

	// DeleteProjectFunc mocks the DeleteProject method.
	DeleteProjectFunc func(ctx context.Context, id pgtype.UUID) error

	// DeleteProjectByUserIDFunc mocks the DeleteProjectByUserID method.
	DeleteProjectByUserIDFunc func(ctx context.Context, arg DeleteProjectByUserIDParams) error

	// DeleteSubscriptionByStripeIDFunc mocks the DeleteSubscriptionByStripeID method.
	DeleteSubscriptionByStripeIDFunc func(ctx context.Context, stripeSubscriptionID string) error

	// DeleteUserFunc mocks the DeleteUser method.
	DeleteUserFunc func(ctx context.Context, id pgtype.UUID) error

	// FailJobFunc mocks the FailJob method.
	FailJobFunc func(ctx context.Context, arg FailJobParams) (*Job, error)

	// GetAllProjectsFunc mocks the GetAllProjects method.
	GetAllProjectsFunc func(ctx context.Context) ([]*GetAllProjectsRow, error)

	// GetImageByIDFunc mocks the GetImageByID method.
	GetImageByIDFunc func(ctx context.Context, id pgtype.UUID) (*Image, error)

	// GetImagesByProjectIDFunc mocks the GetImagesByProjectID method.
	GetImagesByProjectIDFunc func(ctx context.Context, projectID pgtype.UUID) ([]*Image, error)

	// GetInvoiceByStripeIDFunc mocks the GetInvoiceByStripeID method.
	GetInvoiceByStripeIDFunc func(ctx context.Context, stripeInvoiceID string) (*Invoice, error)

	// GetJobByIDFunc mocks the GetJobByID method.
	GetJobByIDFunc func(ctx context.Context, id pgtype.UUID) (*Job, error)

	// GetJobsByImageIDFunc mocks the GetJobsByImageID method.
	GetJobsByImageIDFunc func(ctx context.Context, imageID pgtype.UUID) ([]*Job, error)

	// GetPendingJobsFunc mocks the GetPendingJobs method.
	GetPendingJobsFunc func(ctx context.Context, limit int32) ([]*Job, error)

	// GetProcessedEventByStripeIDFunc mocks the GetProcessedEventByStripeID method.
	GetProcessedEventByStripeIDFunc func(ctx context.Context, stripeEventID string) (*ProcessedEvent, error)

	// GetProjectByIDFunc mocks the GetProjectByID method.
	GetProjectByIDFunc func(ctx context.Context, id pgtype.UUID) (*GetProjectByIDRow, error)

	// GetProjectsByUserIDFunc mocks the GetProjectsByUserID method.
	GetProjectsByUserIDFunc func(ctx context.Context, userID pgtype.UUID) ([]*GetProjectsByUserIDRow, error)

	// GetSubscriptionByStripeIDFunc mocks the GetSubscriptionByStripeID method.
	GetSubscriptionByStripeIDFunc func(ctx context.Context, stripeSubscriptionID string) (*Subscription, error)

	// GetUserByAuth0SubFunc mocks the GetUserByAuth0Sub method.
	GetUserByAuth0SubFunc func(ctx context.Context, auth0Sub string) (*User, error)

	// GetUserByIDFunc mocks the GetUserByID method.
	GetUserByIDFunc func(ctx context.Context, id pgtype.UUID) (*User, error)

	// GetUserByStripeCustomerIDFunc mocks the GetUserByStripeCustomerID method.
	GetUserByStripeCustomerIDFunc func(ctx context.Context, stripeCustomerID pgtype.Text) (*User, error)

	// ListImagesForReconcileFunc mocks the ListImagesForReconcile method.
	ListImagesForReconcileFunc func(ctx context.Context, arg ListImagesForReconcileParams) ([]*Image, error)

	// ListInvoicesByUserIDFunc mocks the ListInvoicesByUserID method.
	ListInvoicesByUserIDFunc func(ctx context.Context, arg ListInvoicesByUserIDParams) ([]*Invoice, error)

	// ListSubscriptionsByUserIDFunc mocks the ListSubscriptionsByUserID method.
	ListSubscriptionsByUserIDFunc func(ctx context.Context, arg ListSubscriptionsByUserIDParams) ([]*Subscription, error)

	// ListUsersFunc mocks the ListUsers method.
	ListUsersFunc func(ctx context.Context, arg ListUsersParams) ([]*User, error)

	// StartJobFunc mocks the StartJob method.
	StartJobFunc func(ctx context.Context, id pgtype.UUID) (*Job, error)

	// UpdateImageStatusFunc mocks the UpdateImageStatus method.
	UpdateImageStatusFunc func(ctx context.Context, arg UpdateImageStatusParams) (*Image, error)

	// UpdateImageWithErrorFunc mocks the UpdateImageWithError method.
	UpdateImageWithErrorFunc func(ctx context.Context, arg UpdateImageWithErrorParams) (*Image, error)

	// UpdateImageWithStagedURLFunc mocks the UpdateImageWithStagedURL method.
	UpdateImageWithStagedURLFunc func(ctx context.Context, arg UpdateImageWithStagedURLParams) (*Image, error)

	// UpdateJobStatusFunc mocks the UpdateJobStatus method.
	UpdateJobStatusFunc func(ctx context.Context, arg UpdateJobStatusParams) (*Job, error)

	// UpdateProjectFunc mocks the UpdateProject method.
	UpdateProjectFunc func(ctx context.Context, arg UpdateProjectParams) (*UpdateProjectRow, error)

	// UpdateProjectByUserIDFunc mocks the UpdateProjectByUserID method.
	UpdateProjectByUserIDFunc func(ctx context.Context, arg UpdateProjectByUserIDParams) (*UpdateProjectByUserIDRow, error)

	// UpdateUserRoleFunc mocks the UpdateUserRole method.
	UpdateUserRoleFunc func(ctx context.Context, arg UpdateUserRoleParams) (*User, error)

	// UpdateUserStripeCustomerIDFunc mocks the UpdateUserStripeCustomerID method.
	UpdateUserStripeCustomerIDFunc func(ctx context.Context, arg UpdateUserStripeCustomerIDParams) (*User, error)

	// UpsertInvoiceByStripeIDFunc mocks the UpsertInvoiceByStripeID method.
	UpsertInvoiceByStripeIDFunc func(ctx context.Context, arg UpsertInvoiceByStripeIDParams) (*Invoice, error)

	// UpsertProcessedEventByStripeIDFunc mocks the UpsertProcessedEventByStripeID method.
	UpsertProcessedEventByStripeIDFunc func(ctx context.Context, arg UpsertProcessedEventByStripeIDParams) (*ProcessedEvent, error)

	// UpsertSubscriptionByStripeIDFunc mocks the UpsertSubscriptionByStripeID method.
	UpsertSubscriptionByStripeIDFunc func(ctx context.Context, arg UpsertSubscriptionByStripeIDParams) (*Subscription, error)

	// calls tracks calls to the methods.
	calls struct {
		// CompleteJob holds details about calls to the CompleteJob method.
		CompleteJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// CountProjectsByUserID holds details about calls to the CountProjectsByUserID method.
		CountProjectsByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID pgtype.UUID
		}
		// CountUsers holds details about calls to the CountUsers method.
		CountUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateImage holds details about calls to the CreateImage method.
		CreateImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg CreateImageParams
		}
		// CreateJob holds details about calls to the CreateJob method.
		CreateJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg CreateJobParams
		}
		// CreateProcessedEvent holds details about calls to the CreateProcessedEvent method.
		CreateProcessedEvent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg CreateProcessedEventParams
		}
		// CreateProject holds details about calls to the CreateProject method.
		CreateProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg CreateProjectParams
		}
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg CreateUserParams
		}
		// DeleteImage holds details about calls to the DeleteImage method.
		DeleteImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// DeleteImagesByProjectID holds details about calls to the DeleteImagesByProjectID method.
		DeleteImagesByProjectID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID pgtype.UUID
		}
		// DeleteJob holds details about calls to the DeleteJob method.
		DeleteJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// DeleteJobsByImageID holds details about calls to the DeleteJobsByImageID method.
		DeleteJobsByImageID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID pgtype.UUID
		}
		// DeleteOldProcessedEvents holds details about calls to the DeleteOldProcessedEvents method.
		DeleteOldProcessedEvents []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReceivedAt is the receivedAt argument value.
			ReceivedAt pgtype.Timestamptz
		}
		// DeleteProject holds details about calls to the DeleteProject method.
		DeleteProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// DeleteProjectByUserID holds details about calls to the DeleteProjectByUserID method.
		DeleteProjectByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg DeleteProjectByUserIDParams
		}
		// DeleteSubscriptionByStripeID holds details about calls to the DeleteSubscriptionByStripeID method.
		DeleteSubscriptionByStripeID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StripeSubscriptionID is the stripeSubscriptionID argument value.
			StripeSubscriptionID string
		}
		// DeleteUser holds details about calls to the DeleteUser method.
		DeleteUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// FailJob holds details about calls to the FailJob method.
		FailJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg FailJobParams
		}
		// GetAllProjects holds details about calls to the GetAllProjects method.
		GetAllProjects []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetImageByID holds details about calls to the GetImageByID method.
		GetImageByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetImagesByProjectID holds details about calls to the GetImagesByProjectID method.
		GetImagesByProjectID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProjectID is the projectID argument value.
			ProjectID pgtype.UUID
		}
		// GetInvoiceByStripeID holds details about calls to the GetInvoiceByStripeID method.
		GetInvoiceByStripeID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StripeInvoiceID is the stripeInvoiceID argument value.
			StripeInvoiceID string
		}
		// GetJobByID holds details about calls to the GetJobByID method.
		GetJobByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetJobsByImageID holds details about calls to the GetJobsByImageID method.
		GetJobsByImageID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ImageID is the imageID argument value.
			ImageID pgtype.UUID
		}
		// GetPendingJobs holds details about calls to the GetPendingJobs method.
		GetPendingJobs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int32
		}
		// GetProcessedEventByStripeID holds details about calls to the GetProcessedEventByStripeID method.
		GetProcessedEventByStripeID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StripeEventID is the stripeEventID argument value.
			StripeEventID string
		}
		// GetProjectByID holds details about calls to the GetProjectByID method.
		GetProjectByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetProjectsByUserID holds details about calls to the GetProjectsByUserID method.
		GetProjectsByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID pgtype.UUID
		}
		// GetSubscriptionByStripeID holds details about calls to the GetSubscriptionByStripeID method.
		GetSubscriptionByStripeID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StripeSubscriptionID is the stripeSubscriptionID argument value.
			StripeSubscriptionID string
		}
		// GetUserByAuth0Sub holds details about calls to the GetUserByAuth0Sub method.
		GetUserByAuth0Sub []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Auth0Sub is the auth0Sub argument value.
			Auth0Sub string
		}
		// GetUserByID holds details about calls to the GetUserByID method.
		GetUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// GetUserByStripeCustomerID holds details about calls to the GetUserByStripeCustomerID method.
		GetUserByStripeCustomerID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// StripeCustomerID is the stripeCustomerID argument value.
			StripeCustomerID pgtype.Text
		}
		// ListImagesForReconcile holds details about calls to the ListImagesForReconcile method.
		ListImagesForReconcile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg ListImagesForReconcileParams
		}
		// ListInvoicesByUserID holds details about calls to the ListInvoicesByUserID method.
		ListInvoicesByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg ListInvoicesByUserIDParams
		}
		// ListSubscriptionsByUserID holds details about calls to the ListSubscriptionsByUserID method.
		ListSubscriptionsByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg ListSubscriptionsByUserIDParams
		}
		// ListUsers holds details about calls to the ListUsers method.
		ListUsers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg ListUsersParams
		}
		// StartJob holds details about calls to the StartJob method.
		StartJob []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID pgtype.UUID
		}
		// UpdateImageStatus holds details about calls to the UpdateImageStatus method.
		UpdateImageStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpdateImageStatusParams
		}
		// UpdateImageWithError holds details about calls to the UpdateImageWithError method.
		UpdateImageWithError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpdateImageWithErrorParams
		}
		// UpdateImageWithStagedURL holds details about calls to the UpdateImageWithStagedURL method.
		UpdateImageWithStagedURL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpdateImageWithStagedURLParams
		}
		// UpdateJobStatus holds details about calls to the UpdateJobStatus method.
		UpdateJobStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpdateJobStatusParams
		}
		// UpdateProject holds details about calls to the UpdateProject method.
		UpdateProject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpdateProjectParams
		}
		// UpdateProjectByUserID holds details about calls to the UpdateProjectByUserID method.
		UpdateProjectByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpdateProjectByUserIDParams
		}
		// UpdateUserRole holds details about calls to the UpdateUserRole method.
		UpdateUserRole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpdateUserRoleParams
		}
		// UpdateUserStripeCustomerID holds details about calls to the UpdateUserStripeCustomerID method.
		UpdateUserStripeCustomerID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpdateUserStripeCustomerIDParams
		}
		// UpsertInvoiceByStripeID holds details about calls to the UpsertInvoiceByStripeID method.
		UpsertInvoiceByStripeID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpsertInvoiceByStripeIDParams
		}
		// UpsertProcessedEventByStripeID holds details about calls to the UpsertProcessedEventByStripeID method.
		UpsertProcessedEventByStripeID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpsertProcessedEventByStripeIDParams
		}
		// UpsertSubscriptionByStripeID holds details about calls to the UpsertSubscriptionByStripeID method.
		UpsertSubscriptionByStripeID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Arg is the arg argument value.
			Arg UpsertSubscriptionByStripeIDParams
		}
	}
	lockCompleteJob                    sync.RWMutex
	lockCountProjectsByUserID          sync.RWMutex
	lockCountUsers                     sync.RWMutex
	lockCreateImage                    sync.RWMutex
	lockCreateJob                      sync.RWMutex
	lockCreateProcessedEvent           sync.RWMutex
	lockCreateProject                  sync.RWMutex
	lockCreateUser                     sync.RWMutex
	lockDeleteImage                    sync.RWMutex
	lockDeleteImagesByProjectID        sync.RWMutex
	lockDeleteJob                      sync.RWMutex
	lockDeleteJobsByImageID            sync.RWMutex
	lockDeleteOldProcessedEvents       sync.RWMutex
	lockDeleteProject                  sync.RWMutex
	lockDeleteProjectByUserID          sync.RWMutex
	lockDeleteSubscriptionByStripeID   sync.RWMutex
	lockDeleteUser                     sync.RWMutex
	lockFailJob                        sync.RWMutex
	lockGetAllProjects                 sync.RWMutex
	lockGetImageByID                   sync.RWMutex
	lockGetImagesByProjectID           sync.RWMutex
	lockGetInvoiceByStripeID           sync.RWMutex
	lockGetJobByID                     sync.RWMutex
	lockGetJobsByImageID               sync.RWMutex
	lockGetPendingJobs                 sync.RWMutex
	lockGetProcessedEventByStripeID    sync.RWMutex
	lockGetProjectByID                 sync.RWMutex
	lockGetProjectsByUserID            sync.RWMutex
	lockGetSubscriptionByStripeID      sync.RWMutex
	lockGetUserByAuth0Sub              sync.RWMutex
	lockGetUserByID                    sync.RWMutex
	lockGetUserByStripeCustomerID      sync.RWMutex
	lockListImagesForReconcile         sync.RWMutex
	lockListInvoicesByUserID           sync.RWMutex
	lockListSubscriptionsByUserID      sync.RWMutex
	lockListUsers                      sync.RWMutex
	lockStartJob                       sync.RWMutex
	lockUpdateImageStatus              sync.RWMutex
	lockUpdateImageWithError           sync.RWMutex
	lockUpdateImageWithStagedURL       sync.RWMutex
	lockUpdateJobStatus                sync.RWMutex
	lockUpdateProject                  sync.RWMutex
	lockUpdateProjectByUserID          sync.RWMutex
	lockUpdateUserRole                 sync.RWMutex
	lockUpdateUserStripeCustomerID     sync.RWMutex
	lockUpsertInvoiceByStripeID        sync.RWMutex
	lockUpsertProcessedEventByStripeID sync.RWMutex
	lockUpsertSubscriptionByStripeID   sync.RWMutex
}

// CompleteJob calls CompleteJobFunc.
func (mock *QuerierMock) CompleteJob(ctx context.Context, id pgtype.UUID) (*Job, error) {
	if mock.CompleteJobFunc == nil {
		panic("QuerierMock.CompleteJobFunc: method is nil but Querier.CompleteJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockCompleteJob.Lock()
	mock.calls.CompleteJob = append(mock.calls.CompleteJob, callInfo)
	mock.lockCompleteJob.Unlock()
	return mock.CompleteJobFunc(ctx, id)
}

// CompleteJobCalls gets all the calls that were made to CompleteJob.
// Check the length with:
//
//	len(mockedQuerier.CompleteJobCalls())
func (mock *QuerierMock) CompleteJobCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockCompleteJob.RLock()
	calls = mock.calls.CompleteJob
	mock.lockCompleteJob.RUnlock()
	return calls
}

// CountProjectsByUserID calls CountProjectsByUserIDFunc.
func (mock *QuerierMock) CountProjectsByUserID(ctx context.Context, userID pgtype.UUID) (int64, error) {
	if mock.CountProjectsByUserIDFunc == nil {
		panic("QuerierMock.CountProjectsByUserIDFunc: method is nil but Querier.CountProjectsByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID pgtype.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockCountProjectsByUserID.Lock()
	mock.calls.CountProjectsByUserID = append(mock.calls.CountProjectsByUserID, callInfo)
	mock.lockCountProjectsByUserID.Unlock()
	return mock.CountProjectsByUserIDFunc(ctx, userID)
}

// CountProjectsByUserIDCalls gets all the calls that were made to CountProjectsByUserID.
// Check the length with:
//
//	len(mockedQuerier.CountProjectsByUserIDCalls())
func (mock *QuerierMock) CountProjectsByUserIDCalls() []struct {
	Ctx    context.Context
	UserID pgtype.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID pgtype.UUID
	}
	mock.lockCountProjectsByUserID.RLock()
	calls = mock.calls.CountProjectsByUserID
	mock.lockCountProjectsByUserID.RUnlock()
	return calls
}

// CountUsers calls CountUsersFunc.
func (mock *QuerierMock) CountUsers(ctx context.Context) (int64, error) {
	if mock.CountUsersFunc == nil {
		panic("QuerierMock.CountUsersFunc: method is nil but Querier.CountUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCountUsers.Lock()
	mock.calls.CountUsers = append(mock.calls.CountUsers, callInfo)
	mock.lockCountUsers.Unlock()
	return mock.CountUsersFunc(ctx)
}

// CountUsersCalls gets all the calls that were made to CountUsers.
// Check the length with:
//
//	len(mockedQuerier.CountUsersCalls())
func (mock *QuerierMock) CountUsersCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCountUsers.RLock()
	calls = mock.calls.CountUsers
	mock.lockCountUsers.RUnlock()
	return calls
}

// CreateImage calls CreateImageFunc.
func (mock *QuerierMock) CreateImage(ctx context.Context, arg CreateImageParams) (*Image, error) {
	if mock.CreateImageFunc == nil {
		panic("QuerierMock.CreateImageFunc: method is nil but Querier.CreateImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg CreateImageParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateImage.Lock()
	mock.calls.CreateImage = append(mock.calls.CreateImage, callInfo)
	mock.lockCreateImage.Unlock()
	return mock.CreateImageFunc(ctx, arg)
}

// CreateImageCalls gets all the calls that were made to CreateImage.
// Check the length with:
//
//	len(mockedQuerier.CreateImageCalls())
func (mock *QuerierMock) CreateImageCalls() []struct {
	Ctx context.Context
	Arg CreateImageParams
} {
	var calls []struct {
		Ctx context.Context
		Arg CreateImageParams
	}
	mock.lockCreateImage.RLock()
	calls = mock.calls.CreateImage
	mock.lockCreateImage.RUnlock()
	return calls
}

// CreateJob calls CreateJobFunc.
func (mock *QuerierMock) CreateJob(ctx context.Context, arg CreateJobParams) (*Job, error) {
	if mock.CreateJobFunc == nil {
		panic("QuerierMock.CreateJobFunc: method is nil but Querier.CreateJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg CreateJobParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateJob.Lock()
	mock.calls.CreateJob = append(mock.calls.CreateJob, callInfo)
	mock.lockCreateJob.Unlock()
	return mock.CreateJobFunc(ctx, arg)
}

// CreateJobCalls gets all the calls that were made to CreateJob.
// Check the length with:
//
//	len(mockedQuerier.CreateJobCalls())
func (mock *QuerierMock) CreateJobCalls() []struct {
	Ctx context.Context
	Arg CreateJobParams
} {
	var calls []struct {
		Ctx context.Context
		Arg CreateJobParams
	}
	mock.lockCreateJob.RLock()
	calls = mock.calls.CreateJob
	mock.lockCreateJob.RUnlock()
	return calls
}

// CreateProcessedEvent calls CreateProcessedEventFunc.
func (mock *QuerierMock) CreateProcessedEvent(ctx context.Context, arg CreateProcessedEventParams) (*ProcessedEvent, error) {
	if mock.CreateProcessedEventFunc == nil {
		panic("QuerierMock.CreateProcessedEventFunc: method is nil but Querier.CreateProcessedEvent was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg CreateProcessedEventParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateProcessedEvent.Lock()
	mock.calls.CreateProcessedEvent = append(mock.calls.CreateProcessedEvent, callInfo)
	mock.lockCreateProcessedEvent.Unlock()
	return mock.CreateProcessedEventFunc(ctx, arg)
}

// CreateProcessedEventCalls gets all the calls that were made to CreateProcessedEvent.
// Check the length with:
//
//	len(mockedQuerier.CreateProcessedEventCalls())
func (mock *QuerierMock) CreateProcessedEventCalls() []struct {
	Ctx context.Context
	Arg CreateProcessedEventParams
} {
	var calls []struct {
		Ctx context.Context
		Arg CreateProcessedEventParams
	}
	mock.lockCreateProcessedEvent.RLock()
	calls = mock.calls.CreateProcessedEvent
	mock.lockCreateProcessedEvent.RUnlock()
	return calls
}

// CreateProject calls CreateProjectFunc.
func (mock *QuerierMock) CreateProject(ctx context.Context, arg CreateProjectParams) (*CreateProjectRow, error) {
	if mock.CreateProjectFunc == nil {
		panic("QuerierMock.CreateProjectFunc: method is nil but Querier.CreateProject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg CreateProjectParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateProject.Lock()
	mock.calls.CreateProject = append(mock.calls.CreateProject, callInfo)
	mock.lockCreateProject.Unlock()
	return mock.CreateProjectFunc(ctx, arg)
}

// CreateProjectCalls gets all the calls that were made to CreateProject.
// Check the length with:
//
//	len(mockedQuerier.CreateProjectCalls())
func (mock *QuerierMock) CreateProjectCalls() []struct {
	Ctx context.Context
	Arg CreateProjectParams
} {
	var calls []struct {
		Ctx context.Context
		Arg CreateProjectParams
	}
	mock.lockCreateProject.RLock()
	calls = mock.calls.CreateProject
	mock.lockCreateProject.RUnlock()
	return calls
}

// CreateUser calls CreateUserFunc.
func (mock *QuerierMock) CreateUser(ctx context.Context, arg CreateUserParams) (*User, error) {
	if mock.CreateUserFunc == nil {
		panic("QuerierMock.CreateUserFunc: method is nil but Querier.CreateUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg CreateUserParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(ctx, arg)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockedQuerier.CreateUserCalls())
func (mock *QuerierMock) CreateUserCalls() []struct {
	Ctx context.Context
	Arg CreateUserParams
} {
	var calls []struct {
		Ctx context.Context
		Arg CreateUserParams
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// DeleteImage calls DeleteImageFunc.
func (mock *QuerierMock) DeleteImage(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteImageFunc == nil {
		panic("QuerierMock.DeleteImageFunc: method is nil but Querier.DeleteImage was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteImage.Lock()
	mock.calls.DeleteImage = append(mock.calls.DeleteImage, callInfo)
	mock.lockDeleteImage.Unlock()
	return mock.DeleteImageFunc(ctx, id)
}

// DeleteImageCalls gets all the calls that were made to DeleteImage.
// Check the length with:
//
//	len(mockedQuerier.DeleteImageCalls())
func (mock *QuerierMock) DeleteImageCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDeleteImage.RLock()
	calls = mock.calls.DeleteImage
	mock.lockDeleteImage.RUnlock()
	return calls
}

// DeleteImagesByProjectID calls DeleteImagesByProjectIDFunc.
func (mock *QuerierMock) DeleteImagesByProjectID(ctx context.Context, projectID pgtype.UUID) error {
	if mock.DeleteImagesByProjectIDFunc == nil {
		panic("QuerierMock.DeleteImagesByProjectIDFunc: method is nil but Querier.DeleteImagesByProjectID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID pgtype.UUID
	}{
		Ctx:       ctx,
		ProjectID: projectID,
	}
	mock.lockDeleteImagesByProjectID.Lock()
	mock.calls.DeleteImagesByProjectID = append(mock.calls.DeleteImagesByProjectID, callInfo)
	mock.lockDeleteImagesByProjectID.Unlock()
	return mock.DeleteImagesByProjectIDFunc(ctx, projectID)
}

// DeleteImagesByProjectIDCalls gets all the calls that were made to DeleteImagesByProjectID.
// Check the length with:
//
//	len(mockedQuerier.DeleteImagesByProjectIDCalls())
func (mock *QuerierMock) DeleteImagesByProjectIDCalls() []struct {
	Ctx       context.Context
	ProjectID pgtype.UUID
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID pgtype.UUID
	}
	mock.lockDeleteImagesByProjectID.RLock()
	calls = mock.calls.DeleteImagesByProjectID
	mock.lockDeleteImagesByProjectID.RUnlock()
	return calls
}

// DeleteJob calls DeleteJobFunc.
func (mock *QuerierMock) DeleteJob(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteJobFunc == nil {
		panic("QuerierMock.DeleteJobFunc: method is nil but Querier.DeleteJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteJob.Lock()
	mock.calls.DeleteJob = append(mock.calls.DeleteJob, callInfo)
	mock.lockDeleteJob.Unlock()
	return mock.DeleteJobFunc(ctx, id)
}

// DeleteJobCalls gets all the calls that were made to DeleteJob.
// Check the length with:
//
//	len(mockedQuerier.DeleteJobCalls())
func (mock *QuerierMock) DeleteJobCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDeleteJob.RLock()
	calls = mock.calls.DeleteJob
	mock.lockDeleteJob.RUnlock()
	return calls
}

// DeleteJobsByImageID calls DeleteJobsByImageIDFunc.
func (mock *QuerierMock) DeleteJobsByImageID(ctx context.Context, imageID pgtype.UUID) error {
	if mock.DeleteJobsByImageIDFunc == nil {
		panic("QuerierMock.DeleteJobsByImageIDFunc: method is nil but Querier.DeleteJobsByImageID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ImageID pgtype.UUID
	}{
		Ctx:     ctx,
		ImageID: imageID,
	}
	mock.lockDeleteJobsByImageID.Lock()
	mock.calls.DeleteJobsByImageID = append(mock.calls.DeleteJobsByImageID, callInfo)
	mock.lockDeleteJobsByImageID.Unlock()
	return mock.DeleteJobsByImageIDFunc(ctx, imageID)
}

// DeleteJobsByImageIDCalls gets all the calls that were made to DeleteJobsByImageID.
// Check the length with:
//
//	len(mockedQuerier.DeleteJobsByImageIDCalls())
func (mock *QuerierMock) DeleteJobsByImageIDCalls() []struct {
	Ctx     context.Context
	ImageID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		ImageID pgtype.UUID
	}
	mock.lockDeleteJobsByImageID.RLock()
	calls = mock.calls.DeleteJobsByImageID
	mock.lockDeleteJobsByImageID.RUnlock()
	return calls
}

// DeleteOldProcessedEvents calls DeleteOldProcessedEventsFunc.
func (mock *QuerierMock) DeleteOldProcessedEvents(ctx context.Context, receivedAt pgtype.Timestamptz) error {
	if mock.DeleteOldProcessedEventsFunc == nil {
		panic("QuerierMock.DeleteOldProcessedEventsFunc: method is nil but Querier.DeleteOldProcessedEvents was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ReceivedAt pgtype.Timestamptz
	}{
		Ctx:        ctx,
		ReceivedAt: receivedAt,
	}
	mock.lockDeleteOldProcessedEvents.Lock()
	mock.calls.DeleteOldProcessedEvents = append(mock.calls.DeleteOldProcessedEvents, callInfo)
	mock.lockDeleteOldProcessedEvents.Unlock()
	return mock.DeleteOldProcessedEventsFunc(ctx, receivedAt)
}

// DeleteOldProcessedEventsCalls gets all the calls that were made to DeleteOldProcessedEvents.
// Check the length with:
//
//	len(mockedQuerier.DeleteOldProcessedEventsCalls())
func (mock *QuerierMock) DeleteOldProcessedEventsCalls() []struct {
	Ctx        context.Context
	ReceivedAt pgtype.Timestamptz
} {
	var calls []struct {
		Ctx        context.Context
		ReceivedAt pgtype.Timestamptz
	}
	mock.lockDeleteOldProcessedEvents.RLock()
	calls = mock.calls.DeleteOldProcessedEvents
	mock.lockDeleteOldProcessedEvents.RUnlock()
	return calls
}

// DeleteProject calls DeleteProjectFunc.
func (mock *QuerierMock) DeleteProject(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteProjectFunc == nil {
		panic("QuerierMock.DeleteProjectFunc: method is nil but Querier.DeleteProject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteProject.Lock()
	mock.calls.DeleteProject = append(mock.calls.DeleteProject, callInfo)
	mock.lockDeleteProject.Unlock()
	return mock.DeleteProjectFunc(ctx, id)
}

// DeleteProjectCalls gets all the calls that were made to DeleteProject.
// Check the length with:
//
//	len(mockedQuerier.DeleteProjectCalls())
func (mock *QuerierMock) DeleteProjectCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDeleteProject.RLock()
	calls = mock.calls.DeleteProject
	mock.lockDeleteProject.RUnlock()
	return calls
}

// DeleteProjectByUserID calls DeleteProjectByUserIDFunc.
func (mock *QuerierMock) DeleteProjectByUserID(ctx context.Context, arg DeleteProjectByUserIDParams) error {
	if mock.DeleteProjectByUserIDFunc == nil {
		panic("QuerierMock.DeleteProjectByUserIDFunc: method is nil but Querier.DeleteProjectByUserID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg DeleteProjectByUserIDParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockDeleteProjectByUserID.Lock()
	mock.calls.DeleteProjectByUserID = append(mock.calls.DeleteProjectByUserID, callInfo)
	mock.lockDeleteProjectByUserID.Unlock()
	return mock.DeleteProjectByUserIDFunc(ctx, arg)
}

// DeleteProjectByUserIDCalls gets all the calls that were made to DeleteProjectByUserID.
// Check the length with:
//
//	len(mockedQuerier.DeleteProjectByUserIDCalls())
func (mock *QuerierMock) DeleteProjectByUserIDCalls() []struct {
	Ctx context.Context
	Arg DeleteProjectByUserIDParams
} {
	var calls []struct {
		Ctx context.Context
		Arg DeleteProjectByUserIDParams
	}
	mock.lockDeleteProjectByUserID.RLock()
	calls = mock.calls.DeleteProjectByUserID
	mock.lockDeleteProjectByUserID.RUnlock()
	return calls
}

// DeleteSubscriptionByStripeID calls DeleteSubscriptionByStripeIDFunc.
func (mock *QuerierMock) DeleteSubscriptionByStripeID(ctx context.Context, stripeSubscriptionID string) error {
	if mock.DeleteSubscriptionByStripeIDFunc == nil {
		panic("QuerierMock.DeleteSubscriptionByStripeIDFunc: method is nil but Querier.DeleteSubscriptionByStripeID was just called")
	}
	callInfo := struct {
		Ctx                  context.Context
		StripeSubscriptionID string
	}{
		Ctx:                  ctx,
		StripeSubscriptionID: stripeSubscriptionID,
	}
	mock.lockDeleteSubscriptionByStripeID.Lock()
	mock.calls.DeleteSubscriptionByStripeID = append(mock.calls.DeleteSubscriptionByStripeID, callInfo)
	mock.lockDeleteSubscriptionByStripeID.Unlock()
	return mock.DeleteSubscriptionByStripeIDFunc(ctx, stripeSubscriptionID)
}

// DeleteSubscriptionByStripeIDCalls gets all the calls that were made to DeleteSubscriptionByStripeID.
// Check the length with:
//
//	len(mockedQuerier.DeleteSubscriptionByStripeIDCalls())
func (mock *QuerierMock) DeleteSubscriptionByStripeIDCalls() []struct {
	Ctx                  context.Context
	StripeSubscriptionID string
} {
	var calls []struct {
		Ctx                  context.Context
		StripeSubscriptionID string
	}
	mock.lockDeleteSubscriptionByStripeID.RLock()
	calls = mock.calls.DeleteSubscriptionByStripeID
	mock.lockDeleteSubscriptionByStripeID.RUnlock()
	return calls
}

// DeleteUser calls DeleteUserFunc.
func (mock *QuerierMock) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	if mock.DeleteUserFunc == nil {
		panic("QuerierMock.DeleteUserFunc: method is nil but Querier.DeleteUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteUser.Lock()
	mock.calls.DeleteUser = append(mock.calls.DeleteUser, callInfo)
	mock.lockDeleteUser.Unlock()
	return mock.DeleteUserFunc(ctx, id)
}

// DeleteUserCalls gets all the calls that were made to DeleteUser.
// Check the length with:
//
//	len(mockedQuerier.DeleteUserCalls())
func (mock *QuerierMock) DeleteUserCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockDeleteUser.RLock()
	calls = mock.calls.DeleteUser
	mock.lockDeleteUser.RUnlock()
	return calls
}

// FailJob calls FailJobFunc.
func (mock *QuerierMock) FailJob(ctx context.Context, arg FailJobParams) (*Job, error) {
	if mock.FailJobFunc == nil {
		panic("QuerierMock.FailJobFunc: method is nil but Querier.FailJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg FailJobParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockFailJob.Lock()
	mock.calls.FailJob = append(mock.calls.FailJob, callInfo)
	mock.lockFailJob.Unlock()
	return mock.FailJobFunc(ctx, arg)
}

// FailJobCalls gets all the calls that were made to FailJob.
// Check the length with:
//
//	len(mockedQuerier.FailJobCalls())
func (mock *QuerierMock) FailJobCalls() []struct {
	Ctx context.Context
	Arg FailJobParams
} {
	var calls []struct {
		Ctx context.Context
		Arg FailJobParams
	}
	mock.lockFailJob.RLock()
	calls = mock.calls.FailJob
	mock.lockFailJob.RUnlock()
	return calls
}

// GetAllProjects calls GetAllProjectsFunc.
func (mock *QuerierMock) GetAllProjects(ctx context.Context) ([]*GetAllProjectsRow, error) {
	if mock.GetAllProjectsFunc == nil {
		panic("QuerierMock.GetAllProjectsFunc: method is nil but Querier.GetAllProjects was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetAllProjects.Lock()
	mock.calls.GetAllProjects = append(mock.calls.GetAllProjects, callInfo)
	mock.lockGetAllProjects.Unlock()
	return mock.GetAllProjectsFunc(ctx)
}

// GetAllProjectsCalls gets all the calls that were made to GetAllProjects.
// Check the length with:
//
//	len(mockedQuerier.GetAllProjectsCalls())
func (mock *QuerierMock) GetAllProjectsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetAllProjects.RLock()
	calls = mock.calls.GetAllProjects
	mock.lockGetAllProjects.RUnlock()
	return calls
}

// GetImageByID calls GetImageByIDFunc.
func (mock *QuerierMock) GetImageByID(ctx context.Context, id pgtype.UUID) (*Image, error) {
	if mock.GetImageByIDFunc == nil {
		panic("QuerierMock.GetImageByIDFunc: method is nil but Querier.GetImageByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetImageByID.Lock()
	mock.calls.GetImageByID = append(mock.calls.GetImageByID, callInfo)
	mock.lockGetImageByID.Unlock()
	return mock.GetImageByIDFunc(ctx, id)
}

// GetImageByIDCalls gets all the calls that were made to GetImageByID.
// Check the length with:
//
//	len(mockedQuerier.GetImageByIDCalls())
func (mock *QuerierMock) GetImageByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetImageByID.RLock()
	calls = mock.calls.GetImageByID
	mock.lockGetImageByID.RUnlock()
	return calls
}

// GetImagesByProjectID calls GetImagesByProjectIDFunc.
func (mock *QuerierMock) GetImagesByProjectID(ctx context.Context, projectID pgtype.UUID) ([]*Image, error) {
	if mock.GetImagesByProjectIDFunc == nil {
		panic("QuerierMock.GetImagesByProjectIDFunc: method is nil but Querier.GetImagesByProjectID was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProjectID pgtype.UUID
	}{
		Ctx:       ctx,
		ProjectID: projectID,
	}
	mock.lockGetImagesByProjectID.Lock()
	mock.calls.GetImagesByProjectID = append(mock.calls.GetImagesByProjectID, callInfo)
	mock.lockGetImagesByProjectID.Unlock()
	return mock.GetImagesByProjectIDFunc(ctx, projectID)
}

// GetImagesByProjectIDCalls gets all the calls that were made to GetImagesByProjectID.
// Check the length with:
//
//	len(mockedQuerier.GetImagesByProjectIDCalls())
func (mock *QuerierMock) GetImagesByProjectIDCalls() []struct {
	Ctx       context.Context
	ProjectID pgtype.UUID
} {
	var calls []struct {
		Ctx       context.Context
		ProjectID pgtype.UUID
	}
	mock.lockGetImagesByProjectID.RLock()
	calls = mock.calls.GetImagesByProjectID
	mock.lockGetImagesByProjectID.RUnlock()
	return calls
}

// GetInvoiceByStripeID calls GetInvoiceByStripeIDFunc.
func (mock *QuerierMock) GetInvoiceByStripeID(ctx context.Context, stripeInvoiceID string) (*Invoice, error) {
	if mock.GetInvoiceByStripeIDFunc == nil {
		panic("QuerierMock.GetInvoiceByStripeIDFunc: method is nil but Querier.GetInvoiceByStripeID was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		StripeInvoiceID string
	}{
		Ctx:             ctx,
		StripeInvoiceID: stripeInvoiceID,
	}
	mock.lockGetInvoiceByStripeID.Lock()
	mock.calls.GetInvoiceByStripeID = append(mock.calls.GetInvoiceByStripeID, callInfo)
	mock.lockGetInvoiceByStripeID.Unlock()
	return mock.GetInvoiceByStripeIDFunc(ctx, stripeInvoiceID)
}

// GetInvoiceByStripeIDCalls gets all the calls that were made to GetInvoiceByStripeID.
// Check the length with:
//
//	len(mockedQuerier.GetInvoiceByStripeIDCalls())
func (mock *QuerierMock) GetInvoiceByStripeIDCalls() []struct {
	Ctx             context.Context
	StripeInvoiceID string
} {
	var calls []struct {
		Ctx             context.Context
		StripeInvoiceID string
	}
	mock.lockGetInvoiceByStripeID.RLock()
	calls = mock.calls.GetInvoiceByStripeID
	mock.lockGetInvoiceByStripeID.RUnlock()
	return calls
}

// GetJobByID calls GetJobByIDFunc.
func (mock *QuerierMock) GetJobByID(ctx context.Context, id pgtype.UUID) (*Job, error) {
	if mock.GetJobByIDFunc == nil {
		panic("QuerierMock.GetJobByIDFunc: method is nil but Querier.GetJobByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetJobByID.Lock()
	mock.calls.GetJobByID = append(mock.calls.GetJobByID, callInfo)
	mock.lockGetJobByID.Unlock()
	return mock.GetJobByIDFunc(ctx, id)
}

// GetJobByIDCalls gets all the calls that were made to GetJobByID.
// Check the length with:
//
//	len(mockedQuerier.GetJobByIDCalls())
func (mock *QuerierMock) GetJobByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetJobByID.RLock()
	calls = mock.calls.GetJobByID
	mock.lockGetJobByID.RUnlock()
	return calls
}

// GetJobsByImageID calls GetJobsByImageIDFunc.
func (mock *QuerierMock) GetJobsByImageID(ctx context.Context, imageID pgtype.UUID) ([]*Job, error) {
	if mock.GetJobsByImageIDFunc == nil {
		panic("QuerierMock.GetJobsByImageIDFunc: method is nil but Querier.GetJobsByImageID was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		ImageID pgtype.UUID
	}{
		Ctx:     ctx,
		ImageID: imageID,
	}
	mock.lockGetJobsByImageID.Lock()
	mock.calls.GetJobsByImageID = append(mock.calls.GetJobsByImageID, callInfo)
	mock.lockGetJobsByImageID.Unlock()
	return mock.GetJobsByImageIDFunc(ctx, imageID)
}

// GetJobsByImageIDCalls gets all the calls that were made to GetJobsByImageID.
// Check the length with:
//
//	len(mockedQuerier.GetJobsByImageIDCalls())
func (mock *QuerierMock) GetJobsByImageIDCalls() []struct {
	Ctx     context.Context
	ImageID pgtype.UUID
} {
	var calls []struct {
		Ctx     context.Context
		ImageID pgtype.UUID
	}
	mock.lockGetJobsByImageID.RLock()
	calls = mock.calls.GetJobsByImageID
	mock.lockGetJobsByImageID.RUnlock()
	return calls
}

// GetPendingJobs calls GetPendingJobsFunc.
func (mock *QuerierMock) GetPendingJobs(ctx context.Context, limit int32) ([]*Job, error) {
	if mock.GetPendingJobsFunc == nil {
		panic("QuerierMock.GetPendingJobsFunc: method is nil but Querier.GetPendingJobs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int32
	}{
		Ctx:   ctx,
		Limit: limit,
	}
	mock.lockGetPendingJobs.Lock()
	mock.calls.GetPendingJobs = append(mock.calls.GetPendingJobs, callInfo)
	mock.lockGetPendingJobs.Unlock()
	return mock.GetPendingJobsFunc(ctx, limit)
}

// GetPendingJobsCalls gets all the calls that were made to GetPendingJobs.
// Check the length with:
//
//	len(mockedQuerier.GetPendingJobsCalls())
func (mock *QuerierMock) GetPendingJobsCalls() []struct {
	Ctx   context.Context
	Limit int32
} {
	var calls []struct {
		Ctx   context.Context
		Limit int32
	}
	mock.lockGetPendingJobs.RLock()
	calls = mock.calls.GetPendingJobs
	mock.lockGetPendingJobs.RUnlock()
	return calls
}

// GetProcessedEventByStripeID calls GetProcessedEventByStripeIDFunc.
func (mock *QuerierMock) GetProcessedEventByStripeID(ctx context.Context, stripeEventID string) (*ProcessedEvent, error) {
	if mock.GetProcessedEventByStripeIDFunc == nil {
		panic("QuerierMock.GetProcessedEventByStripeIDFunc: method is nil but Querier.GetProcessedEventByStripeID was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		StripeEventID string
	}{
		Ctx:           ctx,
		StripeEventID: stripeEventID,
	}
	mock.lockGetProcessedEventByStripeID.Lock()
	mock.calls.GetProcessedEventByStripeID = append(mock.calls.GetProcessedEventByStripeID, callInfo)
	mock.lockGetProcessedEventByStripeID.Unlock()
	return mock.GetProcessedEventByStripeIDFunc(ctx, stripeEventID)
}

// GetProcessedEventByStripeIDCalls gets all the calls that were made to GetProcessedEventByStripeID.
// Check the length with:
//
//	len(mockedQuerier.GetProcessedEventByStripeIDCalls())
func (mock *QuerierMock) GetProcessedEventByStripeIDCalls() []struct {
	Ctx           context.Context
	StripeEventID string
} {
	var calls []struct {
		Ctx           context.Context
		StripeEventID string
	}
	mock.lockGetProcessedEventByStripeID.RLock()
	calls = mock.calls.GetProcessedEventByStripeID
	mock.lockGetProcessedEventByStripeID.RUnlock()
	return calls
}

// GetProjectByID calls GetProjectByIDFunc.
func (mock *QuerierMock) GetProjectByID(ctx context.Context, id pgtype.UUID) (*GetProjectByIDRow, error) {
	if mock.GetProjectByIDFunc == nil {
		panic("QuerierMock.GetProjectByIDFunc: method is nil but Querier.GetProjectByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetProjectByID.Lock()
	mock.calls.GetProjectByID = append(mock.calls.GetProjectByID, callInfo)
	mock.lockGetProjectByID.Unlock()
	return mock.GetProjectByIDFunc(ctx, id)
}

// GetProjectByIDCalls gets all the calls that were made to GetProjectByID.
// Check the length with:
//
//	len(mockedQuerier.GetProjectByIDCalls())
func (mock *QuerierMock) GetProjectByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetProjectByID.RLock()
	calls = mock.calls.GetProjectByID
	mock.lockGetProjectByID.RUnlock()
	return calls
}

// GetProjectsByUserID calls GetProjectsByUserIDFunc.
func (mock *QuerierMock) GetProjectsByUserID(ctx context.Context, userID pgtype.UUID) ([]*GetProjectsByUserIDRow, error) {
	if mock.GetProjectsByUserIDFunc == nil {
		panic("QuerierMock.GetProjectsByUserIDFunc: method is nil but Querier.GetProjectsByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID pgtype.UUID
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetProjectsByUserID.Lock()
	mock.calls.GetProjectsByUserID = append(mock.calls.GetProjectsByUserID, callInfo)
	mock.lockGetProjectsByUserID.Unlock()
	return mock.GetProjectsByUserIDFunc(ctx, userID)
}

// GetProjectsByUserIDCalls gets all the calls that were made to GetProjectsByUserID.
// Check the length with:
//
//	len(mockedQuerier.GetProjectsByUserIDCalls())
func (mock *QuerierMock) GetProjectsByUserIDCalls() []struct {
	Ctx    context.Context
	UserID pgtype.UUID
} {
	var calls []struct {
		Ctx    context.Context
		UserID pgtype.UUID
	}
	mock.lockGetProjectsByUserID.RLock()
	calls = mock.calls.GetProjectsByUserID
	mock.lockGetProjectsByUserID.RUnlock()
	return calls
}

// GetSubscriptionByStripeID calls GetSubscriptionByStripeIDFunc.
func (mock *QuerierMock) GetSubscriptionByStripeID(ctx context.Context, stripeSubscriptionID string) (*Subscription, error) {
	if mock.GetSubscriptionByStripeIDFunc == nil {
		panic("QuerierMock.GetSubscriptionByStripeIDFunc: method is nil but Querier.GetSubscriptionByStripeID was just called")
	}
	callInfo := struct {
		Ctx                  context.Context
		StripeSubscriptionID string
	}{
		Ctx:                  ctx,
		StripeSubscriptionID: stripeSubscriptionID,
	}
	mock.lockGetSubscriptionByStripeID.Lock()
	mock.calls.GetSubscriptionByStripeID = append(mock.calls.GetSubscriptionByStripeID, callInfo)
	mock.lockGetSubscriptionByStripeID.Unlock()
	return mock.GetSubscriptionByStripeIDFunc(ctx, stripeSubscriptionID)
}

// GetSubscriptionByStripeIDCalls gets all the calls that were made to GetSubscriptionByStripeID.
// Check the length with:
//
//	len(mockedQuerier.GetSubscriptionByStripeIDCalls())
func (mock *QuerierMock) GetSubscriptionByStripeIDCalls() []struct {
	Ctx                  context.Context
	StripeSubscriptionID string
} {
	var calls []struct {
		Ctx                  context.Context
		StripeSubscriptionID string
	}
	mock.lockGetSubscriptionByStripeID.RLock()
	calls = mock.calls.GetSubscriptionByStripeID
	mock.lockGetSubscriptionByStripeID.RUnlock()
	return calls
}

// GetUserByAuth0Sub calls GetUserByAuth0SubFunc.
func (mock *QuerierMock) GetUserByAuth0Sub(ctx context.Context, auth0Sub string) (*User, error) {
	if mock.GetUserByAuth0SubFunc == nil {
		panic("QuerierMock.GetUserByAuth0SubFunc: method is nil but Querier.GetUserByAuth0Sub was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Auth0Sub string
	}{
		Ctx:      ctx,
		Auth0Sub: auth0Sub,
	}
	mock.lockGetUserByAuth0Sub.Lock()
	mock.calls.GetUserByAuth0Sub = append(mock.calls.GetUserByAuth0Sub, callInfo)
	mock.lockGetUserByAuth0Sub.Unlock()
	return mock.GetUserByAuth0SubFunc(ctx, auth0Sub)
}

// GetUserByAuth0SubCalls gets all the calls that were made to GetUserByAuth0Sub.
// Check the length with:
//
//	len(mockedQuerier.GetUserByAuth0SubCalls())
func (mock *QuerierMock) GetUserByAuth0SubCalls() []struct {
	Ctx      context.Context
	Auth0Sub string
} {
	var calls []struct {
		Ctx      context.Context
		Auth0Sub string
	}
	mock.lockGetUserByAuth0Sub.RLock()
	calls = mock.calls.GetUserByAuth0Sub
	mock.lockGetUserByAuth0Sub.RUnlock()
	return calls
}

// GetUserByID calls GetUserByIDFunc.
func (mock *QuerierMock) GetUserByID(ctx context.Context, id pgtype.UUID) (*User, error) {
	if mock.GetUserByIDFunc == nil {
		panic("QuerierMock.GetUserByIDFunc: method is nil but Querier.GetUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetUserByID.Lock()
	mock.calls.GetUserByID = append(mock.calls.GetUserByID, callInfo)
	mock.lockGetUserByID.Unlock()
	return mock.GetUserByIDFunc(ctx, id)
}

// GetUserByIDCalls gets all the calls that were made to GetUserByID.
// Check the length with:
//
//	len(mockedQuerier.GetUserByIDCalls())
func (mock *QuerierMock) GetUserByIDCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockGetUserByID.RLock()
	calls = mock.calls.GetUserByID
	mock.lockGetUserByID.RUnlock()
	return calls
}

// GetUserByStripeCustomerID calls GetUserByStripeCustomerIDFunc.
func (mock *QuerierMock) GetUserByStripeCustomerID(ctx context.Context, stripeCustomerID pgtype.Text) (*User, error) {
	if mock.GetUserByStripeCustomerIDFunc == nil {
		panic("QuerierMock.GetUserByStripeCustomerIDFunc: method is nil but Querier.GetUserByStripeCustomerID was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		StripeCustomerID pgtype.Text
	}{
		Ctx:              ctx,
		StripeCustomerID: stripeCustomerID,
	}
	mock.lockGetUserByStripeCustomerID.Lock()
	mock.calls.GetUserByStripeCustomerID = append(mock.calls.GetUserByStripeCustomerID, callInfo)
	mock.lockGetUserByStripeCustomerID.Unlock()
	return mock.GetUserByStripeCustomerIDFunc(ctx, stripeCustomerID)
}

// GetUserByStripeCustomerIDCalls gets all the calls that were made to GetUserByStripeCustomerID.
// Check the length with:
//
//	len(mockedQuerier.GetUserByStripeCustomerIDCalls())
func (mock *QuerierMock) GetUserByStripeCustomerIDCalls() []struct {
	Ctx              context.Context
	StripeCustomerID pgtype.Text
} {
	var calls []struct {
		Ctx              context.Context
		StripeCustomerID pgtype.Text
	}
	mock.lockGetUserByStripeCustomerID.RLock()
	calls = mock.calls.GetUserByStripeCustomerID
	mock.lockGetUserByStripeCustomerID.RUnlock()
	return calls
}

// ListImagesForReconcile calls ListImagesForReconcileFunc.
func (mock *QuerierMock) ListImagesForReconcile(ctx context.Context, arg ListImagesForReconcileParams) ([]*Image, error) {
	if mock.ListImagesForReconcileFunc == nil {
		panic("QuerierMock.ListImagesForReconcileFunc: method is nil but Querier.ListImagesForReconcile was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg ListImagesForReconcileParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockListImagesForReconcile.Lock()
	mock.calls.ListImagesForReconcile = append(mock.calls.ListImagesForReconcile, callInfo)
	mock.lockListImagesForReconcile.Unlock()
	return mock.ListImagesForReconcileFunc(ctx, arg)
}

// ListImagesForReconcileCalls gets all the calls that were made to ListImagesForReconcile.
// Check the length with:
//
//	len(mockedQuerier.ListImagesForReconcileCalls())
func (mock *QuerierMock) ListImagesForReconcileCalls() []struct {
	Ctx context.Context
	Arg ListImagesForReconcileParams
} {
	var calls []struct {
		Ctx context.Context
		Arg ListImagesForReconcileParams
	}
	mock.lockListImagesForReconcile.RLock()
	calls = mock.calls.ListImagesForReconcile
	mock.lockListImagesForReconcile.RUnlock()
	return calls
}

// ListInvoicesByUserID calls ListInvoicesByUserIDFunc.
func (mock *QuerierMock) ListInvoicesByUserID(ctx context.Context, arg ListInvoicesByUserIDParams) ([]*Invoice, error) {
	if mock.ListInvoicesByUserIDFunc == nil {
		panic("QuerierMock.ListInvoicesByUserIDFunc: method is nil but Querier.ListInvoicesByUserID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg ListInvoicesByUserIDParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockListInvoicesByUserID.Lock()
	mock.calls.ListInvoicesByUserID = append(mock.calls.ListInvoicesByUserID, callInfo)
	mock.lockListInvoicesByUserID.Unlock()
	return mock.ListInvoicesByUserIDFunc(ctx, arg)
}

// ListInvoicesByUserIDCalls gets all the calls that were made to ListInvoicesByUserID.
// Check the length with:
//
//	len(mockedQuerier.ListInvoicesByUserIDCalls())
func (mock *QuerierMock) ListInvoicesByUserIDCalls() []struct {
	Ctx context.Context
	Arg ListInvoicesByUserIDParams
} {
	var calls []struct {
		Ctx context.Context
		Arg ListInvoicesByUserIDParams
	}
	mock.lockListInvoicesByUserID.RLock()
	calls = mock.calls.ListInvoicesByUserID
	mock.lockListInvoicesByUserID.RUnlock()
	return calls
}

// ListSubscriptionsByUserID calls ListSubscriptionsByUserIDFunc.
func (mock *QuerierMock) ListSubscriptionsByUserID(ctx context.Context, arg ListSubscriptionsByUserIDParams) ([]*Subscription, error) {
	if mock.ListSubscriptionsByUserIDFunc == nil {
		panic("QuerierMock.ListSubscriptionsByUserIDFunc: method is nil but Querier.ListSubscriptionsByUserID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg ListSubscriptionsByUserIDParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockListSubscriptionsByUserID.Lock()
	mock.calls.ListSubscriptionsByUserID = append(mock.calls.ListSubscriptionsByUserID, callInfo)
	mock.lockListSubscriptionsByUserID.Unlock()
	return mock.ListSubscriptionsByUserIDFunc(ctx, arg)
}

// ListSubscriptionsByUserIDCalls gets all the calls that were made to ListSubscriptionsByUserID.
// Check the length with:
//
//	len(mockedQuerier.ListSubscriptionsByUserIDCalls())
func (mock *QuerierMock) ListSubscriptionsByUserIDCalls() []struct {
	Ctx context.Context
	Arg ListSubscriptionsByUserIDParams
} {
	var calls []struct {
		Ctx context.Context
		Arg ListSubscriptionsByUserIDParams
	}
	mock.lockListSubscriptionsByUserID.RLock()
	calls = mock.calls.ListSubscriptionsByUserID
	mock.lockListSubscriptionsByUserID.RUnlock()
	return calls
}

// ListUsers calls ListUsersFunc.
func (mock *QuerierMock) ListUsers(ctx context.Context, arg ListUsersParams) ([]*User, error) {
	if mock.ListUsersFunc == nil {
		panic("QuerierMock.ListUsersFunc: method is nil but Querier.ListUsers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg ListUsersParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockListUsers.Lock()
	mock.calls.ListUsers = append(mock.calls.ListUsers, callInfo)
	mock.lockListUsers.Unlock()
	return mock.ListUsersFunc(ctx, arg)
}

// ListUsersCalls gets all the calls that were made to ListUsers.
// Check the length with:
//
//	len(mockedQuerier.ListUsersCalls())
func (mock *QuerierMock) ListUsersCalls() []struct {
	Ctx context.Context
	Arg ListUsersParams
} {
	var calls []struct {
		Ctx context.Context
		Arg ListUsersParams
	}
	mock.lockListUsers.RLock()
	calls = mock.calls.ListUsers
	mock.lockListUsers.RUnlock()
	return calls
}

// StartJob calls StartJobFunc.
func (mock *QuerierMock) StartJob(ctx context.Context, id pgtype.UUID) (*Job, error) {
	if mock.StartJobFunc == nil {
		panic("QuerierMock.StartJobFunc: method is nil but Querier.StartJob was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  pgtype.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockStartJob.Lock()
	mock.calls.StartJob = append(mock.calls.StartJob, callInfo)
	mock.lockStartJob.Unlock()
	return mock.StartJobFunc(ctx, id)
}

// StartJobCalls gets all the calls that were made to StartJob.
// Check the length with:
//
//	len(mockedQuerier.StartJobCalls())
func (mock *QuerierMock) StartJobCalls() []struct {
	Ctx context.Context
	ID  pgtype.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  pgtype.UUID
	}
	mock.lockStartJob.RLock()
	calls = mock.calls.StartJob
	mock.lockStartJob.RUnlock()
	return calls
}

// UpdateImageStatus calls UpdateImageStatusFunc.
func (mock *QuerierMock) UpdateImageStatus(ctx context.Context, arg UpdateImageStatusParams) (*Image, error) {
	if mock.UpdateImageStatusFunc == nil {
		panic("QuerierMock.UpdateImageStatusFunc: method is nil but Querier.UpdateImageStatus was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpdateImageStatusParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateImageStatus.Lock()
	mock.calls.UpdateImageStatus = append(mock.calls.UpdateImageStatus, callInfo)
	mock.lockUpdateImageStatus.Unlock()
	return mock.UpdateImageStatusFunc(ctx, arg)
}

// UpdateImageStatusCalls gets all the calls that were made to UpdateImageStatus.
// Check the length with:
//
//	len(mockedQuerier.UpdateImageStatusCalls())
func (mock *QuerierMock) UpdateImageStatusCalls() []struct {
	Ctx context.Context
	Arg UpdateImageStatusParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpdateImageStatusParams
	}
	mock.lockUpdateImageStatus.RLock()
	calls = mock.calls.UpdateImageStatus
	mock.lockUpdateImageStatus.RUnlock()
	return calls
}

// UpdateImageWithError calls UpdateImageWithErrorFunc.
func (mock *QuerierMock) UpdateImageWithError(ctx context.Context, arg UpdateImageWithErrorParams) (*Image, error) {
	if mock.UpdateImageWithErrorFunc == nil {
		panic("QuerierMock.UpdateImageWithErrorFunc: method is nil but Querier.UpdateImageWithError was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpdateImageWithErrorParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateImageWithError.Lock()
	mock.calls.UpdateImageWithError = append(mock.calls.UpdateImageWithError, callInfo)
	mock.lockUpdateImageWithError.Unlock()
	return mock.UpdateImageWithErrorFunc(ctx, arg)
}

// UpdateImageWithErrorCalls gets all the calls that were made to UpdateImageWithError.
// Check the length with:
//
//	len(mockedQuerier.UpdateImageWithErrorCalls())
func (mock *QuerierMock) UpdateImageWithErrorCalls() []struct {
	Ctx context.Context
	Arg UpdateImageWithErrorParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpdateImageWithErrorParams
	}
	mock.lockUpdateImageWithError.RLock()
	calls = mock.calls.UpdateImageWithError
	mock.lockUpdateImageWithError.RUnlock()
	return calls
}

// UpdateImageWithStagedURL calls UpdateImageWithStagedURLFunc.
func (mock *QuerierMock) UpdateImageWithStagedURL(ctx context.Context, arg UpdateImageWithStagedURLParams) (*Image, error) {
	if mock.UpdateImageWithStagedURLFunc == nil {
		panic("QuerierMock.UpdateImageWithStagedURLFunc: method is nil but Querier.UpdateImageWithStagedURL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpdateImageWithStagedURLParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateImageWithStagedURL.Lock()
	mock.calls.UpdateImageWithStagedURL = append(mock.calls.UpdateImageWithStagedURL, callInfo)
	mock.lockUpdateImageWithStagedURL.Unlock()
	return mock.UpdateImageWithStagedURLFunc(ctx, arg)
}

// UpdateImageWithStagedURLCalls gets all the calls that were made to UpdateImageWithStagedURL.
// Check the length with:
//
//	len(mockedQuerier.UpdateImageWithStagedURLCalls())
func (mock *QuerierMock) UpdateImageWithStagedURLCalls() []struct {
	Ctx context.Context
	Arg UpdateImageWithStagedURLParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpdateImageWithStagedURLParams
	}
	mock.lockUpdateImageWithStagedURL.RLock()
	calls = mock.calls.UpdateImageWithStagedURL
	mock.lockUpdateImageWithStagedURL.RUnlock()
	return calls
}

// UpdateJobStatus calls UpdateJobStatusFunc.
func (mock *QuerierMock) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (*Job, error) {
	if mock.UpdateJobStatusFunc == nil {
		panic("QuerierMock.UpdateJobStatusFunc: method is nil but Querier.UpdateJobStatus was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpdateJobStatusParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateJobStatus.Lock()
	mock.calls.UpdateJobStatus = append(mock.calls.UpdateJobStatus, callInfo)
	mock.lockUpdateJobStatus.Unlock()
	return mock.UpdateJobStatusFunc(ctx, arg)
}

// UpdateJobStatusCalls gets all the calls that were made to UpdateJobStatus.
// Check the length with:
//
//	len(mockedQuerier.UpdateJobStatusCalls())
func (mock *QuerierMock) UpdateJobStatusCalls() []struct {
	Ctx context.Context
	Arg UpdateJobStatusParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpdateJobStatusParams
	}
	mock.lockUpdateJobStatus.RLock()
	calls = mock.calls.UpdateJobStatus
	mock.lockUpdateJobStatus.RUnlock()
	return calls
}

// UpdateProject calls UpdateProjectFunc.
func (mock *QuerierMock) UpdateProject(ctx context.Context, arg UpdateProjectParams) (*UpdateProjectRow, error) {
	if mock.UpdateProjectFunc == nil {
		panic("QuerierMock.UpdateProjectFunc: method is nil but Querier.UpdateProject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpdateProjectParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateProject.Lock()
	mock.calls.UpdateProject = append(mock.calls.UpdateProject, callInfo)
	mock.lockUpdateProject.Unlock()
	return mock.UpdateProjectFunc(ctx, arg)
}

// UpdateProjectCalls gets all the calls that were made to UpdateProject.
// Check the length with:
//
//	len(mockedQuerier.UpdateProjectCalls())
func (mock *QuerierMock) UpdateProjectCalls() []struct {
	Ctx context.Context
	Arg UpdateProjectParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpdateProjectParams
	}
	mock.lockUpdateProject.RLock()
	calls = mock.calls.UpdateProject
	mock.lockUpdateProject.RUnlock()
	return calls
}

// UpdateProjectByUserID calls UpdateProjectByUserIDFunc.
func (mock *QuerierMock) UpdateProjectByUserID(ctx context.Context, arg UpdateProjectByUserIDParams) (*UpdateProjectByUserIDRow, error) {
	if mock.UpdateProjectByUserIDFunc == nil {
		panic("QuerierMock.UpdateProjectByUserIDFunc: method is nil but Querier.UpdateProjectByUserID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpdateProjectByUserIDParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateProjectByUserID.Lock()
	mock.calls.UpdateProjectByUserID = append(mock.calls.UpdateProjectByUserID, callInfo)
	mock.lockUpdateProjectByUserID.Unlock()
	return mock.UpdateProjectByUserIDFunc(ctx, arg)
}

// UpdateProjectByUserIDCalls gets all the calls that were made to UpdateProjectByUserID.
// Check the length with:
//
//	len(mockedQuerier.UpdateProjectByUserIDCalls())
func (mock *QuerierMock) UpdateProjectByUserIDCalls() []struct {
	Ctx context.Context
	Arg UpdateProjectByUserIDParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpdateProjectByUserIDParams
	}
	mock.lockUpdateProjectByUserID.RLock()
	calls = mock.calls.UpdateProjectByUserID
	mock.lockUpdateProjectByUserID.RUnlock()
	return calls
}

// UpdateUserRole calls UpdateUserRoleFunc.
func (mock *QuerierMock) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) (*User, error) {
	if mock.UpdateUserRoleFunc == nil {
		panic("QuerierMock.UpdateUserRoleFunc: method is nil but Querier.UpdateUserRole was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpdateUserRoleParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateUserRole.Lock()
	mock.calls.UpdateUserRole = append(mock.calls.UpdateUserRole, callInfo)
	mock.lockUpdateUserRole.Unlock()
	return mock.UpdateUserRoleFunc(ctx, arg)
}

// UpdateUserRoleCalls gets all the calls that were made to UpdateUserRole.
// Check the length with:
//
//	len(mockedQuerier.UpdateUserRoleCalls())
func (mock *QuerierMock) UpdateUserRoleCalls() []struct {
	Ctx context.Context
	Arg UpdateUserRoleParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpdateUserRoleParams
	}
	mock.lockUpdateUserRole.RLock()
	calls = mock.calls.UpdateUserRole
	mock.lockUpdateUserRole.RUnlock()
	return calls
}

// UpdateUserStripeCustomerID calls UpdateUserStripeCustomerIDFunc.
func (mock *QuerierMock) UpdateUserStripeCustomerID(ctx context.Context, arg UpdateUserStripeCustomerIDParams) (*User, error) {
	if mock.UpdateUserStripeCustomerIDFunc == nil {
		panic("QuerierMock.UpdateUserStripeCustomerIDFunc: method is nil but Querier.UpdateUserStripeCustomerID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpdateUserStripeCustomerIDParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpdateUserStripeCustomerID.Lock()
	mock.calls.UpdateUserStripeCustomerID = append(mock.calls.UpdateUserStripeCustomerID, callInfo)
	mock.lockUpdateUserStripeCustomerID.Unlock()
	return mock.UpdateUserStripeCustomerIDFunc(ctx, arg)
}

// UpdateUserStripeCustomerIDCalls gets all the calls that were made to UpdateUserStripeCustomerID.
// Check the length with:
//
//	len(mockedQuerier.UpdateUserStripeCustomerIDCalls())
func (mock *QuerierMock) UpdateUserStripeCustomerIDCalls() []struct {
	Ctx context.Context
	Arg UpdateUserStripeCustomerIDParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpdateUserStripeCustomerIDParams
	}
	mock.lockUpdateUserStripeCustomerID.RLock()
	calls = mock.calls.UpdateUserStripeCustomerID
	mock.lockUpdateUserStripeCustomerID.RUnlock()
	return calls
}

// UpsertInvoiceByStripeID calls UpsertInvoiceByStripeIDFunc.
func (mock *QuerierMock) UpsertInvoiceByStripeID(ctx context.Context, arg UpsertInvoiceByStripeIDParams) (*Invoice, error) {
	if mock.UpsertInvoiceByStripeIDFunc == nil {
		panic("QuerierMock.UpsertInvoiceByStripeIDFunc: method is nil but Querier.UpsertInvoiceByStripeID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpsertInvoiceByStripeIDParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertInvoiceByStripeID.Lock()
	mock.calls.UpsertInvoiceByStripeID = append(mock.calls.UpsertInvoiceByStripeID, callInfo)
	mock.lockUpsertInvoiceByStripeID.Unlock()
	return mock.UpsertInvoiceByStripeIDFunc(ctx, arg)
}

// UpsertInvoiceByStripeIDCalls gets all the calls that were made to UpsertInvoiceByStripeID.
// Check the length with:
//
//	len(mockedQuerier.UpsertInvoiceByStripeIDCalls())
func (mock *QuerierMock) UpsertInvoiceByStripeIDCalls() []struct {
	Ctx context.Context
	Arg UpsertInvoiceByStripeIDParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpsertInvoiceByStripeIDParams
	}
	mock.lockUpsertInvoiceByStripeID.RLock()
	calls = mock.calls.UpsertInvoiceByStripeID
	mock.lockUpsertInvoiceByStripeID.RUnlock()
	return calls
}

// UpsertProcessedEventByStripeID calls UpsertProcessedEventByStripeIDFunc.
func (mock *QuerierMock) UpsertProcessedEventByStripeID(ctx context.Context, arg UpsertProcessedEventByStripeIDParams) (*ProcessedEvent, error) {
	if mock.UpsertProcessedEventByStripeIDFunc == nil {
		panic("QuerierMock.UpsertProcessedEventByStripeIDFunc: method is nil but Querier.UpsertProcessedEventByStripeID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpsertProcessedEventByStripeIDParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertProcessedEventByStripeID.Lock()
	mock.calls.UpsertProcessedEventByStripeID = append(mock.calls.UpsertProcessedEventByStripeID, callInfo)
	mock.lockUpsertProcessedEventByStripeID.Unlock()
	return mock.UpsertProcessedEventByStripeIDFunc(ctx, arg)
}

// UpsertProcessedEventByStripeIDCalls gets all the calls that were made to UpsertProcessedEventByStripeID.
// Check the length with:
//
//	len(mockedQuerier.UpsertProcessedEventByStripeIDCalls())
func (mock *QuerierMock) UpsertProcessedEventByStripeIDCalls() []struct {
	Ctx context.Context
	Arg UpsertProcessedEventByStripeIDParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpsertProcessedEventByStripeIDParams
	}
	mock.lockUpsertProcessedEventByStripeID.RLock()
	calls = mock.calls.UpsertProcessedEventByStripeID
	mock.lockUpsertProcessedEventByStripeID.RUnlock()
	return calls
}

// UpsertSubscriptionByStripeID calls UpsertSubscriptionByStripeIDFunc.
func (mock *QuerierMock) UpsertSubscriptionByStripeID(ctx context.Context, arg UpsertSubscriptionByStripeIDParams) (*Subscription, error) {
	if mock.UpsertSubscriptionByStripeIDFunc == nil {
		panic("QuerierMock.UpsertSubscriptionByStripeIDFunc: method is nil but Querier.UpsertSubscriptionByStripeID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Arg UpsertSubscriptionByStripeIDParams
	}{
		Ctx: ctx,
		Arg: arg,
	}
	mock.lockUpsertSubscriptionByStripeID.Lock()
	mock.calls.UpsertSubscriptionByStripeID = append(mock.calls.UpsertSubscriptionByStripeID, callInfo)
	mock.lockUpsertSubscriptionByStripeID.Unlock()
	return mock.UpsertSubscriptionByStripeIDFunc(ctx, arg)
}

// UpsertSubscriptionByStripeIDCalls gets all the calls that were made to UpsertSubscriptionByStripeID.
// Check the length with:
//
//	len(mockedQuerier.UpsertSubscriptionByStripeIDCalls())
func (mock *QuerierMock) UpsertSubscriptionByStripeIDCalls() []struct {
	Ctx context.Context
	Arg UpsertSubscriptionByStripeIDParams
} {
	var calls []struct {
		Ctx context.Context
		Arg UpsertSubscriptionByStripeIDParams
	}
	mock.lockUpsertSubscriptionByStripeID.RLock()
	calls = mock.calls.UpsertSubscriptionByStripeID
	mock.lockUpsertSubscriptionByStripeID.RUnlock()
	return calls
}
