// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoices.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const GetInvoiceByStripeID = `-- name: GetInvoiceByStripeID :one
SELECT
  id,
  user_id,
  stripe_invoice_id,
  stripe_subscription_id,
  status,
  amount_due,
  amount_paid,
  currency,
  invoice_number,
  created_at,
  updated_at
FROM invoices
WHERE stripe_invoice_id = $1
`

func (q *Queries) GetInvoiceByStripeID(ctx context.Context, stripeInvoiceID string) (*Invoice, error) {
	row := q.db.QueryRow(ctx, GetInvoiceByStripeID, stripeInvoiceID)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StripeInvoiceID,
		&i.StripeSubscriptionID,
		&i.Status,
		&i.AmountDue,
		&i.AmountPaid,
		&i.Currency,
		&i.InvoiceNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListInvoicesByUserID = `-- name: ListInvoicesByUserID :many
SELECT
  id,
  user_id,
  stripe_invoice_id,
  stripe_subscription_id,
  status,
  amount_due,
  amount_paid,
  currency,
  invoice_number,
  created_at,
  updated_at
FROM invoices
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListInvoicesByUserIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListInvoicesByUserID(ctx context.Context, arg ListInvoicesByUserIDParams) ([]*Invoice, error) {
	rows, err := q.db.Query(ctx, ListInvoicesByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StripeInvoiceID,
			&i.StripeSubscriptionID,
			&i.Status,
			&i.AmountDue,
			&i.AmountPaid,
			&i.Currency,
			&i.InvoiceNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertInvoiceByStripeID = `-- name: UpsertInvoiceByStripeID :one

INSERT INTO invoices (
  user_id,
  stripe_invoice_id,
  stripe_subscription_id,
  status,
  amount_due,
  amount_paid,
  currency,
  invoice_number
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (stripe_invoice_id) DO UPDATE SET
  stripe_subscription_id = EXCLUDED.stripe_subscription_id,
  status                 = EXCLUDED.status,
  amount_due             = EXCLUDED.amount_due,
  amount_paid            = EXCLUDED.amount_paid,
  currency               = EXCLUDED.currency,
  invoice_number         = EXCLUDED.invoice_number,
  updated_at             = now()
RETURNING
  id,
  user_id,
  stripe_invoice_id,
  stripe_subscription_id,
  status,
  amount_due,
  amount_paid,
  currency,
  invoice_number,
  created_at,
  updated_at
`

type UpsertInvoiceByStripeIDParams struct {
	UserID               pgtype.UUID `json:"user_id"`
	StripeInvoiceID      string      `json:"stripe_invoice_id"`
	StripeSubscriptionID pgtype.Text `json:"stripe_subscription_id"`
	Status               string      `json:"status"`
	AmountDue            int32       `json:"amount_due"`
	AmountPaid           int32       `json:"amount_paid"`
	Currency             pgtype.Text `json:"currency"`
	InvoiceNumber        pgtype.Text `json:"invoice_number"`
}

// Invoices persistence queries for sqlc generation
// Upsert by unique stripe_invoice_id. We do not modify user_id on conflict.
func (q *Queries) UpsertInvoiceByStripeID(ctx context.Context, arg UpsertInvoiceByStripeIDParams) (*Invoice, error) {
	row := q.db.QueryRow(ctx, UpsertInvoiceByStripeID,
		arg.UserID,
		arg.StripeInvoiceID,
		arg.StripeSubscriptionID,
		arg.Status,
		arg.AmountDue,
		arg.AmountPaid,
		arg.Currency,
		arg.InvoiceNumber,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StripeInvoiceID,
		&i.StripeSubscriptionID,
		&i.Status,
		&i.AmountDue,
		&i.AmountPaid,
		&i.Currency,
		&i.InvoiceNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
