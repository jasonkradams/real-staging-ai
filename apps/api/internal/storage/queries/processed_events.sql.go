// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: processed_events.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateProcessedEvent = `-- name: CreateProcessedEvent :one
INSERT INTO processed_events (stripe_event_id, type, payload)
VALUES ($1, $2, $3)
RETURNING
  id,
  stripe_event_id,
  type,
  payload,
  received_at
`

type CreateProcessedEventParams struct {
	StripeEventID string      `json:"stripe_event_id"`
	Type          pgtype.Text `json:"type"`
	Payload       []byte      `json:"payload"`
}

func (q *Queries) CreateProcessedEvent(ctx context.Context, arg CreateProcessedEventParams) (*ProcessedEvent, error) {
	row := q.db.QueryRow(ctx, CreateProcessedEvent, arg.StripeEventID, arg.Type, arg.Payload)
	var i ProcessedEvent
	err := row.Scan(
		&i.ID,
		&i.StripeEventID,
		&i.Type,
		&i.Payload,
		&i.ReceivedAt,
	)
	return &i, err
}

const DeleteOldProcessedEvents = `-- name: DeleteOldProcessedEvents :exec
DELETE FROM processed_events
WHERE received_at < $1
`

// Optional maintenance: delete older processed events by timestamp (retention)
func (q *Queries) DeleteOldProcessedEvents(ctx context.Context, receivedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, DeleteOldProcessedEvents, receivedAt)
	return err
}

const DeleteSubscriptionByStripeID = `-- name: DeleteSubscriptionByStripeID :exec
DELETE FROM subscriptions
WHERE stripe_subscription_id = $1
`

func (q *Queries) DeleteSubscriptionByStripeID(ctx context.Context, stripeSubscriptionID string) error {
	_, err := q.db.Exec(ctx, DeleteSubscriptionByStripeID, stripeSubscriptionID)
	return err
}

const GetProcessedEventByStripeID = `-- name: GetProcessedEventByStripeID :one

SELECT
  id,
  stripe_event_id,
  type,
  payload,
  received_at
FROM processed_events
WHERE stripe_event_id = $1
`

// Processed Events (Stripe Idempotency)
// sqlc queries for processed_events and subscriptions
func (q *Queries) GetProcessedEventByStripeID(ctx context.Context, stripeEventID string) (*ProcessedEvent, error) {
	row := q.db.QueryRow(ctx, GetProcessedEventByStripeID, stripeEventID)
	var i ProcessedEvent
	err := row.Scan(
		&i.ID,
		&i.StripeEventID,
		&i.Type,
		&i.Payload,
		&i.ReceivedAt,
	)
	return &i, err
}

const GetSubscriptionByStripeID = `-- name: GetSubscriptionByStripeID :one
SELECT
  id,
  user_id,
  stripe_subscription_id,
  status,
  price_id,
  current_period_start,
  current_period_end,
  cancel_at,
  canceled_at,
  cancel_at_period_end,
  created_at,
  updated_at
FROM subscriptions
WHERE stripe_subscription_id = $1
`

func (q *Queries) GetSubscriptionByStripeID(ctx context.Context, stripeSubscriptionID string) (*Subscription, error) {
	row := q.db.QueryRow(ctx, GetSubscriptionByStripeID, stripeSubscriptionID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StripeSubscriptionID,
		&i.Status,
		&i.PriceID,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAt,
		&i.CanceledAt,
		&i.CancelAtPeriodEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListSubscriptionsByUserID = `-- name: ListSubscriptionsByUserID :many
SELECT
  id,
  user_id,
  stripe_subscription_id,
  status,
  price_id,
  current_period_start,
  current_period_end,
  cancel_at,
  canceled_at,
  cancel_at_period_end,
  created_at,
  updated_at
FROM subscriptions
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListSubscriptionsByUserIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListSubscriptionsByUserID(ctx context.Context, arg ListSubscriptionsByUserIDParams) ([]*Subscription, error) {
	rows, err := q.db.Query(ctx, ListSubscriptionsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StripeSubscriptionID,
			&i.Status,
			&i.PriceID,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CancelAt,
			&i.CanceledAt,
			&i.CancelAtPeriodEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertProcessedEventByStripeID = `-- name: UpsertProcessedEventByStripeID :one
INSERT INTO processed_events (stripe_event_id, type, payload)
VALUES ($1, $2, $3)
ON CONFLICT (stripe_event_id) DO UPDATE
SET type = processed_events.type
RETURNING
  id,
  stripe_event_id,
  type,
  payload,
  received_at
`

type UpsertProcessedEventByStripeIDParams struct {
	StripeEventID string      `json:"stripe_event_id"`
	Type          pgtype.Text `json:"type"`
	Payload       []byte      `json:"payload"`
}

// Optional: single-statement upsert that returns the existing/new row.
// Preserves existing values (no-op update) to obtain RETURNING without DO NOTHING.
func (q *Queries) UpsertProcessedEventByStripeID(ctx context.Context, arg UpsertProcessedEventByStripeIDParams) (*ProcessedEvent, error) {
	row := q.db.QueryRow(ctx, UpsertProcessedEventByStripeID, arg.StripeEventID, arg.Type, arg.Payload)
	var i ProcessedEvent
	err := row.Scan(
		&i.ID,
		&i.StripeEventID,
		&i.Type,
		&i.Payload,
		&i.ReceivedAt,
	)
	return &i, err
}

const UpsertSubscriptionByStripeID = `-- name: UpsertSubscriptionByStripeID :one

INSERT INTO subscriptions (
  user_id,
  stripe_subscription_id,
  status,
  price_id,
  current_period_start,
  current_period_end,
  cancel_at,
  canceled_at,
  cancel_at_period_end
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (stripe_subscription_id) DO UPDATE SET
  status = EXCLUDED.status,
  price_id = EXCLUDED.price_id,
  current_period_start = EXCLUDED.current_period_start,
  current_period_end = EXCLUDED.current_period_end,
  cancel_at = EXCLUDED.cancel_at,
  canceled_at = EXCLUDED.canceled_at,
  cancel_at_period_end = EXCLUDED.cancel_at_period_end,
  updated_at = now()
RETURNING
  id,
  user_id,
  stripe_subscription_id,
  status,
  price_id,
  current_period_start,
  current_period_end,
  cancel_at,
  canceled_at,
  cancel_at_period_end,
  created_at,
  updated_at
`

type UpsertSubscriptionByStripeIDParams struct {
	UserID               pgtype.UUID        `json:"user_id"`
	StripeSubscriptionID string             `json:"stripe_subscription_id"`
	Status               string             `json:"status"`
	PriceID              pgtype.Text        `json:"price_id"`
	CurrentPeriodStart   pgtype.Timestamptz `json:"current_period_start"`
	CurrentPeriodEnd     pgtype.Timestamptz `json:"current_period_end"`
	CancelAt             pgtype.Timestamptz `json:"cancel_at"`
	CanceledAt           pgtype.Timestamptz `json:"canceled_at"`
	CancelAtPeriodEnd    bool               `json:"cancel_at_period_end"`
}

// Subscriptions (Stripe subscription state)
// Upsert by unique stripe_subscription_id. We do not modify user_id on conflict.
func (q *Queries) UpsertSubscriptionByStripeID(ctx context.Context, arg UpsertSubscriptionByStripeIDParams) (*Subscription, error) {
	row := q.db.QueryRow(ctx, UpsertSubscriptionByStripeID,
		arg.UserID,
		arg.StripeSubscriptionID,
		arg.Status,
		arg.PriceID,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
		arg.CancelAt,
		arg.CanceledAt,
		arg.CancelAtPeriodEnd,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StripeSubscriptionID,
		&i.Status,
		&i.PriceID,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CancelAt,
		&i.CanceledAt,
		&i.CancelAtPeriodEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
