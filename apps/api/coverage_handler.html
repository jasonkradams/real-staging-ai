
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/real-staging-ai/api/internal/http/admin_handler.go (0.0%)</option>
				
				<option value="file1">github.com/real-staging-ai/api/internal/http/download_handlers.go (0.0%)</option>
				
				<option value="file2">github.com/real-staging-ai/api/internal/http/profile_handler.go (86.2%)</option>
				
				<option value="file3">github.com/real-staging-ai/api/internal/http/pubsub.go (0.0%)</option>
				
				<option value="file4">github.com/real-staging-ai/api/internal/http/server.go (0.0%)</option>
				
				<option value="file5">github.com/real-staging-ai/api/internal/http/upload_handlers.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package http

import (
        "errors"
        "net/http"

        "github.com/jackc/pgx/v5"
        "github.com/labstack/echo/v4"

        "github.com/real-staging-ai/api/internal/auth"
        "github.com/real-staging-ai/api/internal/logging"
        "github.com/real-staging-ai/api/internal/settings"
        "github.com/real-staging-ai/api/internal/storage"
        "github.com/real-staging-ai/api/internal/user"
)

// AdminHandler handles admin-related HTTP requests.
type AdminHandler struct {
        settingsService settings.Service
        db              storage.Database
        log             logging.Logger
}

// NewAdminHandler creates a new AdminHandler.
func NewAdminHandler(settingsService settings.Service, db storage.Database, log logging.Logger) *AdminHandler <span class="cov0" title="0">{
        return &amp;AdminHandler{
                settingsService: settingsService,
                db:              db,
                log:             log,
        }
}</span>

// ListModels handles GET /admin/models - Lists all available AI models.
func (h *AdminHandler) ListModels(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        models, err := h.settingsService.ListAvailableModels(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to list models", "error", err)
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to list models")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "models": models,
        })</span>
}

// GetActiveModel handles GET /admin/models/active - Gets the currently active model.
func (h *AdminHandler) GetActiveModel(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        modelID, err := h.settingsService.GetActiveModel(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to get active model", "error", err)
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to get active model")
        }</span>

        // Get full model info
        <span class="cov0" title="0">models, err := h.settingsService.ListAvailableModels(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to list models", "error", err)
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to get model info")
        }</span>

        <span class="cov0" title="0">var activeModel *settings.ModelInfo
        for _, model := range models </span><span class="cov0" title="0">{
                if model.ID == modelID </span><span class="cov0" title="0">{
                        activeModel = &amp;model
                        break</span>
                }
        }

        <span class="cov0" title="0">if activeModel == nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "Active model not found in registry")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, activeModel)</span>
}

// UpdateActiveModel handles PUT /admin/models/active - Updates the active model.
func (h *AdminHandler) UpdateActiveModel(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        var req settings.UpdateSettingRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
        }</span>

        // Validate required field
        <span class="cov0" title="0">if req.Value == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "value is required")
        }</span>

        // Get user UUID from Auth0 sub
        <span class="cov0" title="0">userUUID, err := h.resolveUserUUID(c)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to resolve user", "error", err)
                return echo.NewHTTPError(http.StatusUnauthorized, map[string]string{
                        "message": "User not authenticated",
                })
        }</span>

        <span class="cov0" title="0">err = h.settingsService.UpdateActiveModel(ctx, req.Value, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to update active model", "error", err, "model_id", req.Value)
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">h.log.Info(ctx, "active model updated", "model_id", req.Value, "user_uuid", userUUID)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message":  "Active model updated successfully",
                "model_id": req.Value,
        })</span>
}

// ListSettings handles GET /admin/settings - Lists all settings.
func (h *AdminHandler) ListSettings(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        settings, err := h.settingsService.ListSettings(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to list settings", "error", err)
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to list settings")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]interface{}{
                "settings": settings,
        })</span>
}

// GetSetting handles GET /admin/settings/:key - Gets a specific setting.
func (h *AdminHandler) GetSetting(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()
        key := c.Param("key")

        setting, err := h.settingsService.GetSetting(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to get setting", "error", err, "key", key)
                return echo.NewHTTPError(http.StatusNotFound, "Setting not found")
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, setting)</span>
}

// UpdateSetting handles PUT /admin/settings/:key - Updates a setting.
func (h *AdminHandler) UpdateSetting(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()
        key := c.Param("key")

        var req settings.UpdateSettingRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
        }</span>

        // Validate required field
        <span class="cov0" title="0">if req.Value == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "value is required")
        }</span>

        // Get user UUID from Auth0 sub
        <span class="cov0" title="0">userUUID, err := h.resolveUserUUID(c)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to resolve user", "error", err)
                return echo.NewHTTPError(http.StatusUnauthorized, map[string]string{
                        "message": "User not authenticated",
                })
        }</span>

        <span class="cov0" title="0">err = h.settingsService.UpdateSetting(ctx, key, req.Value, userUUID)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to update setting", "error", err, "key", key)
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">h.log.Info(ctx, "setting updated", "key", key, "user_uuid", userUUID)

        return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Setting updated successfully",
                "key":     key,
                "value":   req.Value,
        })</span>
}

// resolveUserUUID looks up or creates a user based on Auth0 sub, returning the user's UUID.
func (h *AdminHandler) resolveUserUUID(c echo.Context) (string, error) <span class="cov0" title="0">{
        ctx := c.Request().Context()

        // Get Auth0 sub from JWT token
        auth0Sub, err := auth.GetUserIDOrDefault(c)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Look up user by Auth0 sub
        <span class="cov0" title="0">uRepo := user.NewDefaultRepository(h.db)
        existingUser, err := uRepo.GetByAuth0Sub(ctx, auth0Sub)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        // User doesn't exist, create them
                        newUser, err := uRepo.Create(ctx, auth0Sub, "", "user")
                        if err != nil </span><span class="cov0" title="0">{
                                h.log.Error(ctx, "failed to create user", "error", err, "auth0_sub", auth0Sub)
                                return "", err
                        }</span>
                        <span class="cov0" title="0">return newUser.ID.String(), nil</span>
                }
                <span class="cov0" title="0">h.log.Error(ctx, "failed to get user by auth0 sub", "error", err, "auth0_sub", auth0Sub)
                return "", err</span>
        }

        <span class="cov0" title="0">return existingUser.ID.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package http

import (
        "net/http"
        "net/url"
        "os"
        "strconv"
        "strings"

        "github.com/labstack/echo/v4"
)

// presignImageDownloadHandler handles GET /api/v1/images/:id/presign
// Query params:
// - kind: original|staged (default: original)
// - expires_in: seconds (default: 600)
// - download: 1 to force Content-Disposition=attachment
func (s *Server) presignImageDownloadHandler(c echo.Context) error <span class="cov0" title="0">{
        imageID := c.Param("id")
        if imageID == "" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: "bad_request", Message: "image id is required"})
        }</span>

        <span class="cov0" title="0">kind := strings.ToLower(strings.TrimSpace(c.QueryParam("kind")))
        if kind == "" </span><span class="cov0" title="0">{
                kind = "original"
        }</span>
        <span class="cov0" title="0">expiresIn := int64(600)
        if v := strings.TrimSpace(c.QueryParam("expires_in")); v != "" </span><span class="cov0" title="0">{
                if n, err := strconv.ParseInt(v, 10, 64); err == nil &amp;&amp; n &gt; 0 </span><span class="cov0" title="0">{
                        expiresIn = n
                }</span>
        }
        <span class="cov0" title="0">contentDisposition := ""
        if c.QueryParam("download") == "1" </span><span class="cov0" title="0">{
                contentDisposition = "attachment"
        }</span>

        <span class="cov0" title="0">img, err := s.imageService.GetImageByID(c.Request().Context(), imageID)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusNotFound, ErrorResponse{Error: "not_found", Message: "image not found"})
        }</span>

        <span class="cov0" title="0">var rawURL string
        if kind == "staged" </span><span class="cov0" title="0">{
                if img.StagedURL == nil || *img.StagedURL == "" </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusBadRequest, ErrorResponse{Error: "bad_request", Message: "image has no staged_url"})
                }</span>
                <span class="cov0" title="0">rawURL = *img.StagedURL</span>
        } else<span class="cov0" title="0"> {
                rawURL = img.OriginalURL
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(rawURL)
        if err != nil || u.Path == "" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: "bad_request", Message: "invalid stored URL"})
        }</span>

        <span class="cov0" title="0">bucket := os.Getenv("S3_BUCKET")
        if bucket == "" </span><span class="cov0" title="0">{
                bucket = os.Getenv("S3_BUCKET_NAME")
        }</span>
        <span class="cov0" title="0">if bucket == "" </span><span class="cov0" title="0">{
                bucket = "real-staging"
        }</span>

        // Derive file key from URL path. Expect path-style: /&lt;bucket&gt;/&lt;key&gt;
        <span class="cov0" title="0">p := strings.TrimPrefix(u.Path, "/")
        if !strings.HasPrefix(p, bucket+"/") </span>{<span class="cov0" title="0">
                // fallback: if virtual-hosted style, path is already the key
        }</span> else<span class="cov0" title="0"> {
                p = strings.TrimPrefix(p, bucket+"/")
        }</span>
        <span class="cov0" title="0">fileKey := p
        if fileKey == "" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{Error: "bad_request", Message: "could not derive file key"})
        }</span>

        <span class="cov0" title="0">signed, err := s.s3Service.GeneratePresignedGetURL(c.Request().Context(), fileKey, expiresIn, contentDisposition)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError,
                        ErrorResponse{Error: "internal_server_error", Message: "failed to presign URL"})
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]string{"url": signed})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/real-staging-ai/api/internal/auth"
        "github.com/real-staging-ai/api/internal/logging"
        "github.com/real-staging-ai/api/internal/user"
)

// ProfileHandler handles user profile HTTP requests.
type ProfileHandler struct {
        profileService user.ProfileService
        log            logging.Logger
}

// NewProfileHandler creates a new ProfileHandler.
func NewProfileHandler(profileService user.ProfileService, log logging.Logger) *ProfileHandler <span class="cov8" title="1">{
        return &amp;ProfileHandler{
                profileService: profileService,
                log:            log,
        }
}</span>

// GetProfile handles GET /api/v1/user/profile - Gets the authenticated user's profile.
func (h *ProfileHandler) GetProfile(c echo.Context) error <span class="cov8" title="1">{
        ctx := c.Request().Context()

        // Get Auth0 subject from JWT token
        auth0Sub, err := auth.GetUserIDOrDefault(c)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to get auth0 subject", "error", err)
                return echo.NewHTTPError(http.StatusUnauthorized, "Authentication required")
        }</span>

        // Get profile by Auth0 subject
        <span class="cov8" title="1">profile, err := h.profileService.GetProfileByAuth0Sub(ctx, auth0Sub)
        if err != nil </span><span class="cov8" title="1">{
                h.log.Error(ctx, "failed to get user profile", "error", err, "auth0_sub", auth0Sub)
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to retrieve profile")
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, profile)</span>
}

// UpdateProfile handles PATCH /api/v1/user/profile - Updates the authenticated user's profile.
func (h *ProfileHandler) UpdateProfile(c echo.Context) error <span class="cov8" title="1">{
        ctx := c.Request().Context()

        // Get Auth0 subject from JWT token
        auth0Sub, err := auth.GetUserIDOrDefault(c)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error(ctx, "failed to get auth0 subject", "error", err)
                return echo.NewHTTPError(http.StatusUnauthorized, "Authentication required")
        }</span>

        // Get current profile to obtain user ID
        <span class="cov8" title="1">currentProfile, err := h.profileService.GetProfileByAuth0Sub(ctx, auth0Sub)
        if err != nil </span><span class="cov8" title="1">{
                h.log.Error(ctx, "failed to get current profile", "error", err, "auth0_sub", auth0Sub)
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to retrieve profile")
        }</span>

        // Parse request body
        <span class="cov8" title="1">var req user.ProfileUpdateRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov8" title="1">{
                h.log.Error(ctx, "failed to bind request", "error", err)
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
        }</span>

        // Update profile
        <span class="cov8" title="1">updated, err := h.profileService.UpdateProfile(ctx, currentProfile.ID, &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                h.log.Error(ctx, "failed to update profile", "error", err, "user_id", currentProfile.ID)
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to update profile")
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, updated)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package http

import (
        "context"
        "errors"
        "os"

        redis "github.com/redis/go-redis/v9"
)

// PubSub defines the minimal interface used by SSE for subscription.
type PubSub interface {
        Subscribe(ctx context.Context, channel string) (&lt;-chan []byte, func() error, error)
}

// NewDefaultPubSubFromEnv creates a Redis-backed PubSub if REDIS_ADDR is set.
func NewDefaultPubSubFromEnv() (PubSub, error) <span class="cov0" title="0">{
        addr := os.Getenv("REDIS_ADDR")
        if addr == "" </span><span class="cov0" title="0">{
                return nil, errors.New("REDIS_ADDR not set")
        }</span>
        <span class="cov0" title="0">rdb := redis.NewClient(&amp;redis.Options{Addr: addr})
        return &amp;redisPubSub{rdb: rdb}, nil</span>
}

type redisPubSub struct {
        rdb *redis.Client
}

func (r *redisPubSub) Subscribe(ctx context.Context, channel string) (&lt;-chan []byte, func() error, error) <span class="cov0" title="0">{
        sub := r.rdb.Subscribe(ctx, channel)
        ch := make(chan []byte)

        // Start a goroutine to forward messages
        go func() </span><span class="cov0" title="0">{
                defer close(ch)
                for msg := range sub.Channel() </span><span class="cov0" title="0">{
                        select </span>{
                        case ch &lt;- []byte(msg.Payload):<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">unsubscribe := func() error </span><span class="cov0" title="0">{ return sub.Unsubscribe(context.Background(), channel) }</span>
        <span class="cov0" title="0">return ch, unsubscribe, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package http provides the HTTP server and route handlers.
package http

import (
        "context"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
        "go.opentelemetry.io/contrib/instrumentation/github.com/labstack/echo/otelecho"

        "github.com/real-staging-ai/api/internal/auth"
        "github.com/real-staging-ai/api/internal/billing"
        "github.com/real-staging-ai/api/internal/image"
        "github.com/real-staging-ai/api/internal/logging"
        "github.com/real-staging-ai/api/internal/project"
        "github.com/real-staging-ai/api/internal/reconcile"
        "github.com/real-staging-ai/api/internal/settings"
        "github.com/real-staging-ai/api/internal/sse"
        "github.com/real-staging-ai/api/internal/storage"
        "github.com/real-staging-ai/api/internal/stripe"
        "github.com/real-staging-ai/api/internal/user"
        webdocs "github.com/real-staging-ai/api/web"
)

// Server holds the dependencies for the HTTP server.
type Server struct {
        ctx       context.Context
        echo      *echo.Echo
        db        storage.Database
        s3Service storage.S3Service

        imageService image.Service
        authConfig   *auth.Auth0Config
        pubsub       PubSub
}

// NewServer creates and configures a new Echo server.
func NewServer(
        auth0Audience string,
        auth0Domain string,
        ctx context.Context,
        db storage.Database,
        imageService image.Service,
        s3Service storage.S3Service,
) *Server <span class="cov0" title="0">{
        e := echo.New()

        // Add OpenTelemetry middleware
        e.Use(otelecho.Middleware("real-staging-api"))

        // Add other middleware
        e.Use(middleware.Logger())
        e.Use(middleware.Recover())
        e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
                AllowOrigins: []string{"http://localhost:3000", "http://localhost:3001"},
                AllowMethods: []string{
                        http.MethodGet, http.MethodHead, http.MethodPut,
                        http.MethodPatch, http.MethodPost, http.MethodDelete,
                },
                AllowHeaders: []string{
                        echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept, echo.HeaderAuthorization,
                },
        }))

        // Initialize Auth0 config
        authConfig := auth.NewAuth0Config(ctx, auth0Domain, auth0Audience)

        imgHandler := image.NewDefaultHandler(imageService)

        // Initialize Pub/Sub (Redis) if configured
        var ps PubSub
        if p, err := NewDefaultPubSubFromEnv(); err == nil </span><span class="cov0" title="0">{
                ps = p
        }</span>

        <span class="cov0" title="0">s := &amp;Server{
                ctx: ctx, db: db, s3Service: s3Service, imageService: imageService, echo: e, authConfig: authConfig, pubsub: ps,
        }

        // Health check route
        e.GET("/health", s.healthCheck)

        // Register routes
        api := e.Group("/api/v1")

        // Public routes (no authentication required)
        api.POST("/stripe/webhook", func(c echo.Context) error </span><span class="cov0" title="0">{
                sh := stripe.NewDefaultHandler(s.db)
                return sh.Webhook(c)
        }</span>)

        // Protected routes (require JWT authentication)
        <span class="cov0" title="0">protected := api.Group("")
        protected.Use(auth.JWTMiddleware(s.authConfig))

        // Project routes
        ph := project.NewDefaultHandler(s.db)
        protected.POST("/projects", ph.Create)
        protected.GET("/projects", ph.List)
        protected.GET("/projects/:id", ph.GetByID)
        protected.DELETE("/projects/:id", ph.Delete)

        // Upload routes
        protected.POST("/uploads/presign", s.presignUploadHandler)

        // Image routes
        protected.POST("/images", imgHandler.CreateImage)
        protected.POST("/images/batch", imgHandler.BatchCreateImages)
        protected.GET("/images/:id", imgHandler.GetImage)
        protected.GET("/images/:id/presign", s.presignImageDownloadHandler)
        protected.DELETE("/images/:id", imgHandler.DeleteImage)
        protected.GET("/projects/:project_id/images", imgHandler.GetProjectImages)
        protected.GET("/projects/:project_id/cost", imgHandler.GetProjectCost)

        // SSE routes
        protected.GET("/events", func(c echo.Context) error </span><span class="cov0" title="0">{
                cfg := sse.Config{
                        SubscribeTimeout: 2000000000,
                }
                h, err := sse.NewDefaultHandlerFromEnv(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusServiceUnavailable, map[string]string{"error": "pubsub not configured"})
                }</span>
                <span class="cov0" title="0">return h.Events(c)</span>
        })

        // Billing routes
        <span class="cov0" title="0">bh := billing.NewDefaultHandler(s.db)
        protected.GET("/billing/subscriptions", bh.GetMySubscriptions)
        protected.GET("/billing/invoices", bh.GetMyInvoices)

        // User profile routes
        userRepo := user.NewDefaultRepository(s.db)
        profileService := user.NewDefaultProfileService(userRepo)
        profileHandler := NewProfileHandler(profileService, logging.Default())
        protected.GET("/user/profile", profileHandler.GetProfile)
        protected.PATCH("/user/profile", profileHandler.UpdateProfile)

        // Admin routes (feature-flagged)
        admin := protected.Group("/admin")
        reconcileSvc := reconcile.NewDefaultService(s.db, s.s3Service)
        reconcileHandler := reconcile.NewDefaultHandler(reconcileSvc)
        admin.POST("/reconcile/images", reconcileHandler.ReconcileImages)

        // Admin settings routes
        settingsRepo := settings.NewDefaultRepository(s.db.Pool())
        settingsService := settings.NewDefaultService(settingsRepo)
        adminHandler := NewAdminHandler(settingsService, s.db, logging.Default())
        admin.GET("/models", adminHandler.ListModels)
        admin.GET("/models/active", adminHandler.GetActiveModel)
        admin.PUT("/models/active", adminHandler.UpdateActiveModel)
        admin.GET("/settings", adminHandler.ListSettings)
        admin.GET("/settings/:key", adminHandler.GetSetting)
        admin.PUT("/settings/:key", adminHandler.UpdateSetting)

        // Serve API documentation (embedded)
        webdocs.RegisterRoutes(e)

        return s</span>
}

// NewTestServer creates a new Echo server for testing without Auth0 middleware.
func NewTestServer(db storage.Database, s3Service storage.S3Service, imageService image.Service) *Server <span class="cov0" title="0">{
        e := echo.New()

        // Add basic middleware (no Auth0 for testing)
        e.Use(middleware.Logger())
        e.Use(middleware.Recover())
        e.Use(middleware.CORS())

        imgHandler := image.NewDefaultHandler(imageService)

        s := &amp;Server{db: db, s3Service: s3Service, imageService: imageService, echo: e, authConfig: nil}

        // Health check route (same as main server)
        e.GET("/health", s.healthCheck)

        // Register routes without authentication
        api := e.Group("/api/v1")

        // All routes are public for testing
        api.POST("/stripe/webhook", func(c echo.Context) error </span><span class="cov0" title="0">{
                sh := stripe.NewDefaultHandler(s.db)
                return sh.Webhook(c)
        }</span>)

        // Project routes (no auth required for testing)
        <span class="cov0" title="0">ph := project.NewDefaultHandler(s.db)
        api.POST("/projects", withTestUser(ph.Create))
        api.GET("/projects", withTestUser(ph.List))
        api.GET("/projects/:id", withTestUser(ph.GetByID))
        api.PUT("/projects/:id", withTestUser(ph.Update))
        api.DELETE("/projects/:id", withTestUser(ph.Delete))

        // Upload routes
        api.POST("/uploads/presign", s.presignUploadHandler)

        // Image routes
        api.POST("/images", imgHandler.CreateImage)
        api.GET("/images/:id", imgHandler.GetImage)
        api.GET("/images/:id/presign", s.presignImageDownloadHandler)
        api.DELETE("/images/:id", imgHandler.DeleteImage)
        api.GET("/projects/:project_id/images", imgHandler.GetProjectImages)
        api.GET("/projects/:project_id/cost", imgHandler.GetProjectCost)

        // SSE routes
        api.GET("/events", func(c echo.Context) error </span><span class="cov0" title="0">{
                cfg := sse.Config{
                        SubscribeTimeout: 2000000000,
                }
                h, err := sse.NewDefaultHandlerFromEnv(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusServiceUnavailable, map[string]string{"error": "pubsub not configured"})
                }</span>
                <span class="cov0" title="0">return h.Events(c)</span>
        })

        // Billing routes (public in test server)
        <span class="cov0" title="0">bh := billing.NewDefaultHandler(s.db)
        api.GET("/billing/subscriptions", withTestUser(bh.GetMySubscriptions))
        api.GET("/billing/invoices", withTestUser(bh.GetMyInvoices))

        // User profile routes (test server)
        userRepo := user.NewDefaultRepository(s.db)
        profileService := user.NewDefaultProfileService(userRepo)
        profileHandler := NewProfileHandler(profileService, logging.Default())
        api.GET("/user/profile", withTestUser(profileHandler.GetProfile))
        api.PATCH("/user/profile", withTestUser(profileHandler.UpdateProfile))

        // Admin routes (public in test server, feature-flagged)
        admin := api.Group("/admin")
        reconcileSvc := reconcile.NewDefaultService(s.db, s.s3Service)
        reconcileHandler := reconcile.NewDefaultHandler(reconcileSvc)
        admin.POST("/reconcile/images", reconcileHandler.ReconcileImages)

        // Admin settings routes (test server)
        settingsRepo := settings.NewDefaultRepository(s.db.Pool())
        settingsService := settings.NewDefaultService(settingsRepo)
        adminHandler := NewAdminHandler(settingsService, s.db, logging.Default())
        admin.GET("/models", withTestUser(adminHandler.ListModels))
        admin.GET("/models/active", withTestUser(adminHandler.GetActiveModel))
        admin.PUT("/models/active", withTestUser(adminHandler.UpdateActiveModel))
        admin.GET("/settings", withTestUser(adminHandler.ListSettings))
        admin.GET("/settings/:key", withTestUser(adminHandler.GetSetting))
        admin.PUT("/settings/:key", withTestUser(adminHandler.UpdateSetting))

        // Serve API documentation (embedded)
        webdocs.RegisterRoutes(e)

        return s</span>
}

// Start starts the HTTP server.
func (s *Server) Start(addr string) error <span class="cov0" title="0">{
        return s.echo.Start(addr)
}</span>

// ServeHTTP implements the http.Handler interface.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        s.echo.ServeHTTP(w, r)
}</span>

// healthCheck handles GET /api/v1/health requests.
func (s *Server) healthCheck(c echo.Context) error <span class="cov0" title="0">{
        return c.JSON(http.StatusOK, map[string]string{
                "status":  "ok",
                "service": "real-staging-api",
        })
}</span>

// withTestUser ensures an X-Test-User header is present for test-only servers.
// It defaults to the seeded test user to keep integration tests deterministic.
func withTestUser(h echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                if c.Request().Header.Get("X-Test-User") == "" </span><span class="cov0" title="0">{
                        c.Request().Header.Set("X-Test-User", "auth0|testuser")
                }</span>
                <span class="cov0" title="0">return h(c)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package http

import (
        "errors"
        "fmt"
        "net/http"
        "path/filepath"
        "strings"

        "github.com/jackc/pgx/v5"
        "github.com/labstack/echo/v4"

        "github.com/real-staging-ai/api/internal/auth"
        "github.com/real-staging-ai/api/internal/storage"
        "github.com/real-staging-ai/api/internal/user"
)

// ErrorResponse represents an error response.
type ErrorResponse struct {
        Error   string `json:"error"`
        Message string `json:"message"`
}

// ValidationErrorDetail represents a validation error for a specific field.
type ValidationErrorDetail struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// ValidationErrorResponse represents a validation error response.
type ValidationErrorResponse struct {
        Error            string                  `json:"error"`
        Message          string                  `json:"message"`
        ValidationErrors []ValidationErrorDetail `json:"validation_errors"`
}

type PresignUploadRequest struct {
        Filename    string `json:"filename" validate:"required,min=1,max=255"`
        ContentType string `json:"content_type" validate:"required"`
        FileSize    int64  `json:"file_size" validate:"required,min=1,max=10485760"`
}

type PresignUploadResponse struct {
        UploadURL string `json:"upload_url"`
        FileKey   string `json:"file_key"`
        ExpiresIn int64  `json:"expires_in"`
}

func (s *Server) presignUploadHandler(c echo.Context) error <span class="cov0" title="0">{
        var req PresignUploadRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, ErrorResponse{
                        Error:   "bad_request",
                        Message: "Invalid request format",
                })
        }</span>

        // Validate request
        <span class="cov0" title="0">if validationErrs := validatePresignUploadRequest(&amp;req); len(validationErrs) &gt; 0 </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnprocessableEntity, ValidationErrorResponse{
                        Error:            "validation_failed",
                        Message:          "The provided data is invalid",
                        ValidationErrors: validationErrs,
                })
        }</span>

        // Get user ID from JWT token (or default in tests), ensure user exists
        <span class="cov0" title="0">auth0Sub, err := auth.GetUserIDOrDefault(c)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusUnauthorized, ErrorResponse{
                        Error:   "unauthorized",
                        Message: "Invalid or missing JWT token",
                })
        }</span>

        <span class="cov0" title="0">userRepo := user.NewDefaultRepository(s.db)
        existingUser, err := userRepo.GetByAuth0Sub(c.Request().Context(), auth0Sub)
        var userID string
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        // User not found, create a new one
                        newUser, err := userRepo.Create(c.Request().Context(), auth0Sub, "", "user")
                        if err != nil </span><span class="cov0" title="0">{
                                return c.JSON(http.StatusInternalServerError, ErrorResponse{
                                        Error:   "internal_server_error",
                                        Message: "Failed to create user",
                                })
                        }</span>
                        <span class="cov0" title="0">userID = newUser.ID.String()</span>
                } else<span class="cov0" title="0"> {
                        return c.JSON(http.StatusInternalServerError, ErrorResponse{
                                Error:   "internal_server_error",
                                Message: "Failed to get user",
                        })
                }</span>
        } else<span class="cov0" title="0"> {
                userID = existingUser.ID.String()
        }</span>

        // Generate presigned upload URL using injected S3 service
        <span class="cov0" title="0">result, err := s.s3Service.GeneratePresignedUploadURL(
                c.Request().Context(),
                userID,
                req.Filename,
                req.ContentType,
                req.FileSize,
        )
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusInternalServerError, ErrorResponse{
                        Error:   "internal_server_error",
                        Message: fmt.Sprintf("Failed to generate upload URL: %v", err),
                })
        }</span>

        <span class="cov0" title="0">response := PresignUploadResponse{
                UploadURL: result.UploadURL,
                FileKey:   result.FileKey,
                ExpiresIn: result.ExpiresIn,
        }

        return c.JSON(http.StatusOK, response)</span>
}

// Validation helpers for upload requests
func validatePresignUploadRequest(req *PresignUploadRequest) []ValidationErrorDetail <span class="cov0" title="0">{
        var errors []ValidationErrorDetail

        // Validate filename
        filename := strings.TrimSpace(req.Filename)
        switch </span>{
        case filename == "":<span class="cov0" title="0">
                errors = append(errors, ValidationErrorDetail{
                        Field:   "filename",
                        Message: "filename is required",
                })</span>
        case len(filename) &gt; 255:<span class="cov0" title="0">
                errors = append(errors, ValidationErrorDetail{
                        Field:   "filename",
                        Message: "filename must be 255 characters or less",
                })</span>
        case !storage.ValidateFilename(filename):<span class="cov0" title="0">
                errors = append(errors, ValidationErrorDetail{
                        Field:   "filename",
                        Message: "filename must have a valid image extension (.jpg, .jpeg, .png, .webp)",
                })</span>
        }

        // Validate content type
        <span class="cov0" title="0">if req.ContentType == "" </span><span class="cov0" title="0">{
                errors = append(errors, ValidationErrorDetail{
                        Field:   "content_type",
                        Message: "content_type is required",
                })
        }</span> else<span class="cov0" title="0"> if !storage.ValidateContentType(req.ContentType) </span><span class="cov0" title="0">{
                errors = append(errors, ValidationErrorDetail{
                        Field:   "content_type",
                        Message: "content_type must be image/jpeg, image/png, or image/webp",
                })
        }</span>

        // Validate file size
        <span class="cov0" title="0">if req.FileSize &lt;= 0 </span><span class="cov0" title="0">{
                errors = append(errors, ValidationErrorDetail{
                        Field:   "file_size",
                        Message: "file_size must be greater than 0",
                })
        }</span> else<span class="cov0" title="0"> if !storage.ValidateFileSize(req.FileSize) </span><span class="cov0" title="0">{
                errors = append(errors, ValidationErrorDetail{
                        Field:   "file_size",
                        Message: "file_size must be between 1 byte and 10MB",
                })
        }</span>

        // Validate content type matches file extension
        <span class="cov0" title="0">if req.Filename != "" &amp;&amp; req.ContentType != "" </span><span class="cov0" title="0">{
                ext := strings.ToLower(filepath.Ext(req.Filename))
                expectedContentType := getContentTypeFromExtension(ext)
                // If we have a valid image content type but invalid extension, or vice versa
                if (expectedContentType == "" &amp;&amp; storage.ValidateContentType(req.ContentType)) ||
                        (expectedContentType != "" &amp;&amp; req.ContentType != expectedContentType) </span><span class="cov0" title="0">{
                        errors = append(errors, ValidationErrorDetail{
                                Field:   "content_type",
                                Message: fmt.Sprintf("content_type %s doesn't match file extension %s", req.ContentType, ext),
                        })
                }</span>
        }

        <span class="cov0" title="0">return errors</span>
}

func getContentTypeFromExtension(ext string) string <span class="cov0" title="0">{
        switch ext </span>{
        case ".jpg", ".jpeg":<span class="cov0" title="0">
                return "image/jpeg"</span>
        case ".png":<span class="cov0" title="0">
                return "image/png"</span>
        case ".webp":<span class="cov0" title="0">
                return "image/webp"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
